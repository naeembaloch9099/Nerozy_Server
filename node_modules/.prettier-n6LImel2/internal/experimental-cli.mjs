import { createRequire as __prettierCreateRequire } from "module";
import { fileURLToPath as __prettierFileUrlToPath } from "url";
import { dirname as __prettierDirname } from "path";
const require = __prettierCreateRequire(import.meta.url);
const __filename = __prettierFileUrlToPath(import.meta.url);
const __dirname = __prettierDirname(__filename);

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// node_modules/find-up-path/dist/index.js
import fs from "fs";
import path from "path";
import process2 from "process";
var findUpPath, dist_default;
var init_dist = __esm({
  "node_modules/find-up-path/dist/index.js"() {
    findUpPath = (fileName, folderPath = process2.cwd(), maxDepth = 25) => {
      let filePath = path.normalize(path.join(folderPath, fileName));
      let depth = 1;
      while (true) {
        if (depth > maxDepth)
          return;
        if (fs.existsSync(filePath))
          return filePath;
        folderPath = path.resolve(folderPath, "..");
        const filePathNext = path.normalize(path.join(folderPath, fileName));
        if (filePathNext === filePath)
          return;
        filePath = filePathNext;
        depth += 1;
      }
    };
    dist_default = findUpPath;
  }
});

// node_modules/find-up-json/dist/utils.js
var attempt;
var init_utils = __esm({
  "node_modules/find-up-json/dist/utils.js"() {
    attempt = (fn, fallback) => {
      try {
        return fn();
      } catch {
        return fallback;
      }
    };
  }
});

// node_modules/find-up-json/dist/index.js
import { Buffer as Buffer2 } from "buffer";
import fs2 from "fs";
import process3 from "process";
var findUp, dist_default2;
var init_dist2 = __esm({
  "node_modules/find-up-json/dist/index.js"() {
    init_dist();
    init_utils();
    findUp = (fileName, folderPath = process3.cwd(), maxDepth = 25) => {
      const path17 = dist_default(fileName, folderPath, maxDepth);
      if (!path17)
        return;
      const buffer2 = attempt(() => fs2.readFileSync(path17), Buffer2.alloc(0));
      const content = attempt(() => JSON.parse(buffer2.toString()), {});
      return { path: path17, buffer: buffer2, content };
    };
    dist_default2 = findUp;
  }
});

// node_modules/get-current-package/dist/index.js
import fs3 from "fs";
import path2 from "path";
import process4 from "process";
var getCurrentPackage, dist_default3;
var init_dist3 = __esm({
  "node_modules/get-current-package/dist/index.js"() {
    init_dist2();
    getCurrentPackage = () => {
      try {
        const filePath = fs3.realpathSync(process4.argv[1]);
        const folderPath = path2.dirname(filePath);
        const pkg = dist_default2("package.json", folderPath);
        return pkg == null ? void 0 : pkg.content;
      } catch {
        return;
      }
    };
    dist_default3 = getCurrentPackage;
  }
});

// node_modules/tiny-colors/dist/constants.js
var _a, ENV, _a2, ARGV, _a3, _b, _c, ENABLED;
var init_constants = __esm({
  "node_modules/tiny-colors/dist/constants.js"() {
    ENV = ((_a = globalThis.process) == null ? void 0 : _a.env) || {};
    ARGV = ((_a2 = globalThis.process) == null ? void 0 : _a2.argv) || [];
    ENABLED = !("NO_COLOR" in ENV) && ENV.COLOR !== "0" && ENV.TERM !== "dumb" && !ARGV.includes("--no-color") && !ARGV.includes("--no-colors") && (ENV.COLOR === "1" || !((_a3 = globalThis.process) == null ? void 0 : _a3.stdout) || ((_c = (_b = globalThis.process) == null ? void 0 : _b.stdout) == null ? void 0 : _c.isTTY) === true);
  }
});

// node_modules/tiny-colors/dist/index.js
var chain, wrap, colors, dist_default4;
var init_dist4 = __esm({
  "node_modules/tiny-colors/dist/index.js"() {
    init_constants();
    chain = (modifier) => {
      return new Proxy(modifier, {
        get(target, prop) {
          if (prop in colors) {
            return chain((string2) => modifier(colors[prop](string2)));
          } else {
            return target[prop];
          }
        }
      });
    };
    wrap = (start, end) => {
      return chain((string2) => {
        if (!ENABLED)
          return string2;
        return `\x1B[${start}m${string2}\x1B[${end}m`;
      });
    };
    colors = {
      /* MODIFIERS */
      reset: wrap(0, 0),
      bold: wrap(1, 22),
      dim: wrap(2, 22),
      italic: wrap(3, 23),
      underline: wrap(4, 24),
      overline: wrap(53, 55),
      inverse: wrap(7, 27),
      hidden: wrap(8, 28),
      strikethrough: wrap(9, 29),
      /* FOREGOUND */
      black: wrap(30, 39),
      red: wrap(31, 39),
      green: wrap(32, 39),
      yellow: wrap(33, 39),
      blue: wrap(34, 39),
      magenta: wrap(35, 39),
      cyan: wrap(36, 39),
      white: wrap(37, 39),
      gray: wrap(90, 39),
      /* BACKGROUND */
      bgBlack: wrap(40, 49),
      bgRed: wrap(41, 49),
      bgGreen: wrap(42, 49),
      bgYellow: wrap(43, 49),
      bgBlue: wrap(44, 49),
      bgMagenta: wrap(45, 49),
      bgCyan: wrap(46, 49),
      bgWhite: wrap(47, 49),
      bgGray: wrap(100, 49)
    };
    dist_default4 = colors;
  }
});

// node_modules/tiny-parse-argv/dist/utils.js
var castArray, isBoolean, isNil, isNull, isOverridable, isUndefined, setNormal, setVariadic, uniq, uniqBy, without, zip;
var init_utils2 = __esm({
  "node_modules/tiny-parse-argv/dist/utils.js"() {
    castArray = (value) => {
      return Array.isArray(value) ? value : [value];
    };
    isBoolean = (value) => {
      return value === true || value === false;
    };
    isNil = (value) => {
      return value === null || value === void 0;
    };
    isNull = (value) => {
      return value === null;
    };
    isOverridable = (value) => {
      return isNil(value) || isBoolean(value) || value === "";
    };
    isUndefined = (value) => {
      return value === void 0;
    };
    setNormal = (target, key2, value, override) => {
      if (override) {
        target[key2] = value;
      } else if (Array.isArray(target[key2])) {
        target[key2].push(value);
      } else if (isOverridable(target[key2])) {
        target[key2] = value;
      } else {
        target[key2] = [target[key2], value];
      }
    };
    setVariadic = (target, key2, value, override) => {
      const values = castArray(value);
      if (override) {
        target[key2] = values;
      } else if (Array.isArray(target[key2])) {
        target[key2].push(...values);
      } else if (isOverridable(target[key2])) {
        target[key2] = values;
      } else {
        target[key2] = [target[key2], ...values];
      }
    };
    uniq = (values) => {
      return Array.from(new Set(values));
    };
    uniqBy = (values, iterator) => {
      const ids = /* @__PURE__ */ new Set();
      return values.filter((value, index, arr) => {
        const id = iterator(value, index, arr);
        if (ids.has(id))
          return false;
        ids.add(id);
        return true;
      });
    };
    without = (values, value) => {
      return values.filter((other) => other !== value);
    };
    zip = (keys, value) => {
      return Object.fromEntries(Array.from(keys).map((key2) => [key2, value]));
    };
  }
});

// node_modules/tiny-parse-argv/dist/index.js
var getAliasesMap, getAliasedMap, getAliasedSet, getAliasedDefaults, getAliasedIncompatibles, setAliased, parseDoubleHyphen, parseWithRegExp, parseCharSeparator, parseEqualsSeparator, parseImplicitSeparator, parseProto, parseOption, parseOptionNegation, parseValue, unquote, parseArgv, dist_default5;
var init_dist5 = __esm({
  "node_modules/tiny-parse-argv/dist/index.js"() {
    init_utils2();
    getAliasesMap = (aliases = {}) => {
      const map2 = {};
      for (const key2 in aliases) {
        const values = uniq([key2, ...aliases[key2] || []]);
        for (const value of values) {
          if (value in map2)
            continue;
          map2[value] = without(values, value);
        }
      }
      return map2;
    };
    getAliasedMap = (aliases, object) => {
      const map2 = /* @__PURE__ */ new Map();
      for (const key2 in object) {
        const value = object[key2];
        if (isUndefined(value))
          continue;
        map2.set(key2, value);
        const keyAliases = aliases[key2];
        if (!keyAliases)
          continue;
        for (const key3 of keyAliases) {
          map2.set(key3, value);
        }
      }
      return map2;
    };
    getAliasedSet = (aliases, values = []) => {
      const valuesAliases = values.flatMap((value) => aliases[value] || []);
      const valuesAliased = /* @__PURE__ */ new Set([...values, ...valuesAliases]);
      return valuesAliased;
    };
    getAliasedDefaults = (aliases, defaults = {}) => {
      const defaultsAliased = {};
      for (const key2 in defaults) {
        const value = defaults[key2];
        const keys = uniq([key2, ...aliases[key2] || []]);
        for (const key3 of keys) {
          if (key3 in defaultsAliased)
            continue;
          defaultsAliased[key3] = value;
        }
      }
      return defaultsAliased;
    };
    getAliasedIncompatibles = (aliases, incompatibles = {}) => {
      const incompatiblesAliased = {};
      for (const source2 in incompatibles) {
        const sources = getAliasedSet(aliases, [source2]);
        const targets = getAliasedSet(aliases, incompatibles[source2]);
        for (const source3 of sources) {
          for (const target of targets) {
            const sourceSet = incompatiblesAliased[source3] || (incompatiblesAliased[source3] = /* @__PURE__ */ new Set());
            const targetSet = incompatiblesAliased[target] || (incompatiblesAliased[target] = /* @__PURE__ */ new Set());
            sourceSet.add(target);
            targetSet.add(source3);
          }
        }
      }
      return incompatiblesAliased;
    };
    setAliased = (target, key2, value, unary, variadic, aliases) => {
      var _a4;
      const set3 = variadic ? setVariadic : setNormal;
      set3(target, key2, value, unary);
      (_a4 = aliases[key2]) == null ? void 0 : _a4.forEach((alias) => {
        set3(target, alias, value, unary);
      });
    };
    parseDoubleHyphen = (argv) => {
      const index = argv.indexOf("--");
      if (index < 0)
        return [argv, []];
      const parse8 = argv.slice(0, index);
      const preserve = argv.slice(index + 1);
      return [parse8, preserve];
    };
    parseWithRegExp = (argv, re, callback) => {
      return argv.flatMap((arg) => {
        const match2 = re.exec(arg);
        if (!match2)
          return arg;
        return callback(...match2);
      });
    };
    parseCharSeparator = (argv) => {
      const re = /^-([a-zA-Z0-9\.]{2,})([^]*)$/;
      return parseWithRegExp(argv, re, (_, chars2) => chars2.split("").map((char) => `-${char}`));
    };
    parseEqualsSeparator = (argv) => {
      const re = /^(--?[^=][^=]*?)=([^]*)$/;
      const shieldValue = (value) => value.startsWith("-") ? `"${value}"` : value;
      return parseWithRegExp(argv, re, (_, key2, value) => [key2, shieldValue(value)]);
    };
    parseImplicitSeparator = (argv) => {
      const re = /^(--?(?:no-)?\S*?[a-zA-Z]\S*?)((?:[0-9\/]|-(?=$))[^]*)$/;
      return parseWithRegExp(argv, re, (_, key2, value) => [key2, value]);
    };
    parseProto = (argv) => {
      const re = /^--?(no-)?(__proto__|prototype|constructor)$/;
      return argv.filter((arg, index) => !re.test(arg) && !re.test(argv[index - 1]));
    };
    parseOption = (arg) => {
      const optionRe = /^(--?)([^]+)$/;
      const match2 = optionRe.exec(arg);
      if (!match2)
        return;
      return match2[2];
    };
    parseOptionNegation = (arg) => {
      const negationRe = /^no-([^]+)$/;
      const match2 = negationRe.exec(arg);
      if (!match2)
        return [arg, true];
      return [match2[1], false];
    };
    parseValue = (key2, valueRaw, booleans, integers, numbers, strings, validators) => {
      var _a4;
      const value = unquote(String(valueRaw));
      if (((_a4 = validators.get(key2)) == null ? void 0 : _a4(value)) === false) {
        return null;
      }
      if (booleans.has(key2)) {
        if (value === "true")
          return true;
        if (value === "false")
          return false;
      }
      if (integers.has(key2)) {
        const integer = Number(value);
        if (Number.isInteger(integer))
          return integer;
        return null;
      }
      if (numbers.has(key2)) {
        const number = Number(value);
        if (!Number.isNaN(number))
          return number;
        return null;
      }
      if (strings.has(key2) || value !== valueRaw) {
        return value;
      }
      const numberRe = /^0[xX][0-9a-fA-F]+$|^-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][-+]?\d+)?$/;
      if (numberRe.test(value)) {
        return Number(value);
      } else {
        return value;
      }
    };
    unquote = (value) => {
      return value.replace(/^(['"])(\1*)(.*)(\1\2)$/, "$3");
    };
    parseArgv = (argv, options = {}) => {
      const aliases = getAliasesMap(options.alias);
      const booleans = getAliasedSet(aliases, options.boolean);
      const integers = getAliasedSet(aliases, options.integer);
      const numbers = getAliasedSet(aliases, options.number);
      const strings = getAliasedSet(aliases, options.string);
      const eagers = getAliasedSet(aliases, options.eager);
      const unarys = getAliasedSet(aliases, options.unary);
      const variadics = getAliasedSet(aliases, options.variadic);
      const defaults = getAliasedDefaults(aliases, options.default);
      const incompatibles = getAliasedIncompatibles(aliases, options.incompatible);
      const validators = getAliasedMap(aliases, options.validators);
      const required = options.required || [];
      const known = /* @__PURE__ */ new Set([...booleans, ...integers, ...numbers, ...strings, ...Object.keys(defaults)]);
      const found = [];
      const onIncompatible = options.onIncompatible;
      const onInvalid = options.onInvalid;
      const onMissing = options.onMissing;
      const onUnknown = options.onUnknown;
      const [parse8, preserve] = parseDoubleHyphen(argv);
      const parsed = { _: [], "--": preserve };
      const args = parseCharSeparator(parseImplicitSeparator(parseEqualsSeparator(parseProto(parse8))));
      let optionPrev = "";
      let optionEagerPrev = "";
      for (let i = 0, l = args.length; i < l; i++) {
        const arg = args[i];
        const option = parseOption(arg);
        if (option) {
          const [key2, positive] = parseOptionNegation(option);
          if (isOverridable(parsed[key2])) {
            if (!integers.has(key2) && !numbers.has(key2) && !strings.has(key2)) {
              const unary = unarys.has(key2);
              const variadic = variadics.has(key2);
              const value = variadic ? [positive] : positive;
              setAliased(parsed, key2, value, unary, variadic, aliases);
            }
          }
          found.push(key2);
          optionPrev = option;
          optionEagerPrev = eagers.has(key2) ? option : "";
        } else {
          const value = parseValue(optionPrev, arg, booleans, integers, numbers, strings, validators);
          if (optionPrev && (!booleans.has(optionPrev) || isBoolean(value))) {
            if (!isNull(value)) {
              const unary = unarys.has(optionPrev);
              const variadic = variadics.has(optionPrev);
              setAliased(parsed, optionPrev, value, unary, variadic, aliases);
            }
          } else if (optionEagerPrev && !booleans.has(optionEagerPrev)) {
            if (!isNull(value)) {
              const unary = unarys.has(optionEagerPrev);
              const variadic = variadics.has(optionEagerPrev);
              setAliased(parsed, optionEagerPrev, value, unary, variadic, aliases);
            }
          } else {
            parsed._.push(String(value ?? arg));
            optionEagerPrev = "";
          }
          optionPrev = "";
        }
      }
      const parsedWithDefaults = { ...defaults, ...parsed };
      const parsedWithDefaultsAndBooleans = { ...zip(booleans, false), ...parsedWithDefaults };
      if (onUnknown) {
        const unknowns = Object.keys(parsedWithDefaults).filter((key2) => key2 !== "_" && key2 !== "--" && !known.has(key2));
        if (unknowns.length) {
          onUnknown(unknowns);
        }
      }
      if (onMissing) {
        const missings = required.filter((key2) => !(key2 in parsedWithDefaults));
        if (missings.length) {
          onMissing(missings);
        }
      }
      if (onInvalid) {
        const invalids = found.filter((key2) => parsedWithDefaults[key2] === void 0);
        if (invalids.length) {
          onInvalid(invalids);
        }
      }
      if (onIncompatible) {
        const options2 = uniq(found);
        const pairs2 = [];
        for (let si = 0, sl = options2.length; si < sl; si++) {
          const source2 = options2[si];
          const sourceIncompatibles = incompatibles[source2];
          if (!sourceIncompatibles)
            continue;
          for (let ti = si + 1, tl = sl; ti < tl; ti++) {
            const target = options2[ti];
            if (!sourceIncompatibles.has(target))
              continue;
            pairs2.push([source2, target]);
          }
        }
        if (pairs2.length) {
          const pairsUnique = uniqBy(pairs2, (pair) => [...pair].sort().join());
          onIncompatible(pairsUnique);
        }
      }
      return parsedWithDefaultsAndBooleans;
    };
    dist_default5 = parseArgv;
  }
});

// node_modules/ionstore/dist/utils.js
var attempt2;
var init_utils3 = __esm({
  "node_modules/ionstore/dist/utils.js"() {
    attempt2 = (fn, fallback) => {
      try {
        return fn();
      } catch {
        return fallback;
      }
    };
  }
});

// node_modules/ionstore/dist/abstract.js
var __classPrivateFieldSet, __classPrivateFieldGet, _AbstractStore_save, AbstractStore, abstract_default;
var init_abstract = __esm({
  "node_modules/ionstore/dist/abstract.js"() {
    init_utils3();
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    AbstractStore = class extends Map {
      /* CONSTRUCTOR */
      constructor(options) {
        super();
        _AbstractStore_save.set(this, void 0);
        const { id, backend } = options;
        if (!/^[a-zA-Z0-9_-]+$/.test(id))
          throw new Error(`Invalid store id: "${id}"`);
        const read3 = () => attempt2(() => backend.read(id), []);
        const write = () => attempt2(() => backend.write(id, this.entries()), null);
        for (const [key2, value] of read3()) {
          super.set(key2, value);
        }
        __classPrivateFieldSet(this, _AbstractStore_save, write, "f");
        return this;
      }
      /* API */
      clear() {
        if (!this.size)
          return;
        super.clear();
        __classPrivateFieldGet(this, _AbstractStore_save, "f").call(this);
      }
      delete(key2) {
        const deleted = super.delete(key2);
        if (!deleted)
          return false;
        __classPrivateFieldGet(this, _AbstractStore_save, "f").call(this);
        return true;
      }
      set(key2, value) {
        const valuePrev = this.get(key2);
        if (value === valuePrev)
          return this;
        super.set(key2, value);
        __classPrivateFieldGet(this, _AbstractStore_save, "f").call(this);
        return this;
      }
    };
    _AbstractStore_save = /* @__PURE__ */ new WeakMap();
    abstract_default = AbstractStore;
  }
});

// node_modules/ionstore/dist/node.js
import fs4 from "fs";
import os from "os";
import path3 from "path";
var NodeStore, node_default;
var init_node = __esm({
  "node_modules/ionstore/dist/node.js"() {
    init_abstract();
    NodeStore = class extends abstract_default {
      /* CONSTRUCTOR */
      constructor(id) {
        super({
          id,
          backend: {
            read: (id2) => {
              const filePath = path3.join(os.tmpdir(), `ionstore_${id2}.json`);
              const content = fs4.readFileSync(filePath, "utf8");
              return JSON.parse(content);
            },
            write: (id2, data) => {
              const filePath = path3.join(os.tmpdir(), `ionstore_${id2}.json`);
              const content = JSON.stringify(Array.from(data));
              return fs4.writeFileSync(filePath, content);
            }
          }
        });
      }
    };
    node_default = NodeStore;
  }
});

// node_modules/when-exit/dist/node/constants.js
import process5 from "process";
var IS_LINUX, IS_WINDOWS;
var init_constants2 = __esm({
  "node_modules/when-exit/dist/node/constants.js"() {
    IS_LINUX = process5.platform === "linux";
    IS_WINDOWS = process5.platform === "win32";
  }
});

// node_modules/when-exit/dist/node/signals.js
var Signals, signals_default;
var init_signals = __esm({
  "node_modules/when-exit/dist/node/signals.js"() {
    init_constants2();
    Signals = ["SIGABRT", "SIGALRM", "SIGHUP", "SIGINT", "SIGTERM"];
    if (!IS_WINDOWS) {
      Signals.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
    }
    if (IS_LINUX) {
      Signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
    }
    signals_default = Signals;
  }
});

// node_modules/when-exit/dist/node/interceptor.js
import process6 from "process";
var Interceptor, interceptor_default;
var init_interceptor = __esm({
  "node_modules/when-exit/dist/node/interceptor.js"() {
    init_constants2();
    init_signals();
    Interceptor = class {
      /* CONSTRUCTOR */
      constructor() {
        this.callbacks = /* @__PURE__ */ new Set();
        this.exited = false;
        this.exit = (signal) => {
          if (this.exited)
            return;
          this.exited = true;
          for (const callback of this.callbacks) {
            callback();
          }
          if (signal) {
            if (IS_WINDOWS && (signal !== "SIGINT" && signal !== "SIGTERM" && signal !== "SIGKILL")) {
              process6.kill(process6.pid, "SIGTERM");
            } else {
              process6.kill(process6.pid, signal);
            }
          }
        };
        this.hook = () => {
          process6.once("exit", () => this.exit());
          for (const signal of signals_default) {
            try {
              process6.once(signal, () => this.exit(signal));
            } catch {
            }
          }
        };
        this.register = (callback) => {
          this.callbacks.add(callback);
          return () => {
            this.callbacks.delete(callback);
          };
        };
        this.hook();
      }
    };
    interceptor_default = new Interceptor();
  }
});

// node_modules/when-exit/dist/node/index.js
var whenExit, node_default2;
var init_node2 = __esm({
  "node_modules/when-exit/dist/node/index.js"() {
    init_interceptor();
    whenExit = interceptor_default.register;
    node_default2 = whenExit;
  }
});

// node_modules/tiny-updater/dist/compare.js
var compare, compare_default;
var init_compare = __esm({
  "node_modules/tiny-updater/dist/compare.js"() {
    compare = (a, b) => {
      const pa = a.split(".");
      const pb = b.split(".");
      for (let i = 0; i < 3; i++) {
        let na = Number(pa[i]);
        let nb = Number(pb[i]);
        if (na > nb)
          return 1;
        if (nb > na)
          return -1;
        if (!isNaN(na) && isNaN(nb))
          return 1;
        if (isNaN(na) && !isNaN(nb))
          return -1;
      }
      return 0;
    };
    compare_default = compare;
  }
});

// node_modules/tiny-updater/dist/utils.js
var Utils, utils_default;
var init_utils4 = __esm({
  "node_modules/tiny-updater/dist/utils.js"() {
    init_dist4();
    init_node2();
    init_compare();
    Utils = {
      /* API */
      fetch: async (url3) => {
        const signal = Utils.getExitSignal();
        const request = await fetch(url3, { signal });
        const json2 = await request.json();
        return json2;
      },
      getExitSignal: () => {
        const aborter = new AbortController();
        node_default2(() => aborter.abort());
        return aborter.signal;
      },
      getLatestVersion: async (name) => {
        const latestUrl = `https://registry.npmjs.org/${name}/latest`;
        const latest = await Utils.fetch(latestUrl);
        return latest.version;
      },
      isNumber: (value) => {
        return typeof value === "number";
      },
      isString: (value) => {
        return typeof value === "string";
      },
      isUpdateAvailable: (current, latest) => {
        return compare_default(current, latest) === -1;
      },
      noop: () => {
        return;
      },
      notify: (name, version, latest) => {
        var _a4, _b2;
        if (!((_b2 = (_a4 = globalThis.process) == null ? void 0 : _a4.stdout) == null ? void 0 : _b2.isTTY))
          return;
        const log = () => console.log(`

\u{1F4E6} Update available for ${dist_default4.cyan(name)}: ${dist_default4.gray(version)} \u2192 ${dist_default4.green(latest)}`);
        node_default2(log);
      }
    };
    utils_default = Utils;
  }
});

// node_modules/tiny-updater/dist/store.js
var Store, store_default;
var init_store = __esm({
  "node_modules/tiny-updater/dist/store.js"() {
    init_node();
    init_utils4();
    Store = class {
      constructor() {
        this.store = new node_default("tiny-updater");
        this.get = (name) => {
          try {
            const recordRaw = this.store.get(name);
            if (!recordRaw)
              return;
            const record = JSON.parse(recordRaw);
            if (!utils_default.isNumber(record.timestampFetch))
              return;
            if (!utils_default.isNumber(record.timestampNotification))
              return;
            if (!utils_default.isString(record.version))
              return;
            return record;
          } catch {
            return;
          }
        };
        this.set = (name, record) => {
          this.store.set(name, JSON.stringify(record));
        };
      }
    };
    store_default = new Store();
  }
});

// node_modules/tiny-updater/dist/index.js
var updater, dist_default6;
var init_dist6 = __esm({
  "node_modules/tiny-updater/dist/index.js"() {
    init_store();
    init_utils4();
    updater = async ({ name, version, ttl = 0 }) => {
      const record = store_default.get(name);
      const timestamp2 = Date.now();
      const isFresh = !record || timestamp2 - record.timestampFetch >= ttl;
      const latest = isFresh ? await utils_default.getLatestVersion(name).catch(utils_default.noop) : record == null ? void 0 : record.version;
      if (!latest)
        return false;
      if (isFresh) {
        const record2 = { timestampFetch: timestamp2, timestampNotification: timestamp2, version: latest };
        store_default.set(name, record2);
      }
      if (!utils_default.isUpdateAvailable(version, latest)) {
        return false;
      }
      if (isFresh) {
        utils_default.notify(name, version, latest);
      }
      return true;
    };
    dist_default6 = updater;
  }
});

// node_modules/fast-string-truncated-width/dist/utils.js
var isAmbiguous, isFullWidth, isWide;
var init_utils5 = __esm({
  "node_modules/fast-string-truncated-width/dist/utils.js"() {
    isAmbiguous = (x) => {
      return x === 161 || x === 164 || x === 167 || x === 168 || x === 170 || x === 173 || x === 174 || x >= 176 && x <= 180 || x >= 182 && x <= 186 || x >= 188 && x <= 191 || x === 198 || x === 208 || x === 215 || x === 216 || x >= 222 && x <= 225 || x === 230 || x >= 232 && x <= 234 || x === 236 || x === 237 || x === 240 || x === 242 || x === 243 || x >= 247 && x <= 250 || x === 252 || x === 254 || x === 257 || x === 273 || x === 275 || x === 283 || x === 294 || x === 295 || x === 299 || x >= 305 && x <= 307 || x === 312 || x >= 319 && x <= 322 || x === 324 || x >= 328 && x <= 331 || x === 333 || x === 338 || x === 339 || x === 358 || x === 359 || x === 363 || x === 462 || x === 464 || x === 466 || x === 468 || x === 470 || x === 472 || x === 474 || x === 476 || x === 593 || x === 609 || x === 708 || x === 711 || x >= 713 && x <= 715 || x === 717 || x === 720 || x >= 728 && x <= 731 || x === 733 || x === 735 || x >= 768 && x <= 879 || x >= 913 && x <= 929 || x >= 931 && x <= 937 || x >= 945 && x <= 961 || x >= 963 && x <= 969 || x === 1025 || x >= 1040 && x <= 1103 || x === 1105 || x === 8208 || x >= 8211 && x <= 8214 || x === 8216 || x === 8217 || x === 8220 || x === 8221 || x >= 8224 && x <= 8226 || x >= 8228 && x <= 8231 || x === 8240 || x === 8242 || x === 8243 || x === 8245 || x === 8251 || x === 8254 || x === 8308 || x === 8319 || x >= 8321 && x <= 8324 || x === 8364 || x === 8451 || x === 8453 || x === 8457 || x === 8467 || x === 8470 || x === 8481 || x === 8482 || x === 8486 || x === 8491 || x === 8531 || x === 8532 || x >= 8539 && x <= 8542 || x >= 8544 && x <= 8555 || x >= 8560 && x <= 8569 || x === 8585 || x >= 8592 && x <= 8601 || x === 8632 || x === 8633 || x === 8658 || x === 8660 || x === 8679 || x === 8704 || x === 8706 || x === 8707 || x === 8711 || x === 8712 || x === 8715 || x === 8719 || x === 8721 || x === 8725 || x === 8730 || x >= 8733 && x <= 8736 || x === 8739 || x === 8741 || x >= 8743 && x <= 8748 || x === 8750 || x >= 8756 && x <= 8759 || x === 8764 || x === 8765 || x === 8776 || x === 8780 || x === 8786 || x === 8800 || x === 8801 || x >= 8804 && x <= 8807 || x === 8810 || x === 8811 || x === 8814 || x === 8815 || x === 8834 || x === 8835 || x === 8838 || x === 8839 || x === 8853 || x === 8857 || x === 8869 || x === 8895 || x === 8978 || x >= 9312 && x <= 9449 || x >= 9451 && x <= 9547 || x >= 9552 && x <= 9587 || x >= 9600 && x <= 9615 || x >= 9618 && x <= 9621 || x === 9632 || x === 9633 || x >= 9635 && x <= 9641 || x === 9650 || x === 9651 || x === 9654 || x === 9655 || x === 9660 || x === 9661 || x === 9664 || x === 9665 || x >= 9670 && x <= 9672 || x === 9675 || x >= 9678 && x <= 9681 || x >= 9698 && x <= 9701 || x === 9711 || x === 9733 || x === 9734 || x === 9737 || x === 9742 || x === 9743 || x === 9756 || x === 9758 || x === 9792 || x === 9794 || x === 9824 || x === 9825 || x >= 9827 && x <= 9829 || x >= 9831 && x <= 9834 || x === 9836 || x === 9837 || x === 9839 || x === 9886 || x === 9887 || x === 9919 || x >= 9926 && x <= 9933 || x >= 9935 && x <= 9939 || x >= 9941 && x <= 9953 || x === 9955 || x === 9960 || x === 9961 || x >= 9963 && x <= 9969 || x === 9972 || x >= 9974 && x <= 9977 || x === 9979 || x === 9980 || x === 9982 || x === 9983 || x === 10045 || x >= 10102 && x <= 10111 || x >= 11094 && x <= 11097 || x >= 12872 && x <= 12879 || x >= 57344 && x <= 63743 || x >= 65024 && x <= 65039 || x === 65533 || x >= 127232 && x <= 127242 || x >= 127248 && x <= 127277 || x >= 127280 && x <= 127337 || x >= 127344 && x <= 127373 || x === 127375 || x === 127376 || x >= 127387 && x <= 127404 || x >= 917760 && x <= 917999 || x >= 983040 && x <= 1048573 || x >= 1048576 && x <= 1114109;
    };
    isFullWidth = (x) => {
      return x === 12288 || x >= 65281 && x <= 65376 || x >= 65504 && x <= 65510;
    };
    isWide = (x) => {
      return x >= 4352 && x <= 4447 || x === 8986 || x === 8987 || x === 9001 || x === 9002 || x >= 9193 && x <= 9196 || x === 9200 || x === 9203 || x === 9725 || x === 9726 || x === 9748 || x === 9749 || x >= 9800 && x <= 9811 || x === 9855 || x === 9875 || x === 9889 || x === 9898 || x === 9899 || x === 9917 || x === 9918 || x === 9924 || x === 9925 || x === 9934 || x === 9940 || x === 9962 || x === 9970 || x === 9971 || x === 9973 || x === 9978 || x === 9981 || x === 9989 || x === 9994 || x === 9995 || x === 10024 || x === 10060 || x === 10062 || x >= 10067 && x <= 10069 || x === 10071 || x >= 10133 && x <= 10135 || x === 10160 || x === 10175 || x === 11035 || x === 11036 || x === 11088 || x === 11093 || x >= 11904 && x <= 11929 || x >= 11931 && x <= 12019 || x >= 12032 && x <= 12245 || x >= 12272 && x <= 12287 || x >= 12289 && x <= 12350 || x >= 12353 && x <= 12438 || x >= 12441 && x <= 12543 || x >= 12549 && x <= 12591 || x >= 12593 && x <= 12686 || x >= 12688 && x <= 12771 || x >= 12783 && x <= 12830 || x >= 12832 && x <= 12871 || x >= 12880 && x <= 19903 || x >= 19968 && x <= 42124 || x >= 42128 && x <= 42182 || x >= 43360 && x <= 43388 || x >= 44032 && x <= 55203 || x >= 63744 && x <= 64255 || x >= 65040 && x <= 65049 || x >= 65072 && x <= 65106 || x >= 65108 && x <= 65126 || x >= 65128 && x <= 65131 || x >= 94176 && x <= 94180 || x === 94192 || x === 94193 || x >= 94208 && x <= 100343 || x >= 100352 && x <= 101589 || x >= 101632 && x <= 101640 || x >= 110576 && x <= 110579 || x >= 110581 && x <= 110587 || x === 110589 || x === 110590 || x >= 110592 && x <= 110882 || x === 110898 || x >= 110928 && x <= 110930 || x === 110933 || x >= 110948 && x <= 110951 || x >= 110960 && x <= 111355 || x === 126980 || x === 127183 || x === 127374 || x >= 127377 && x <= 127386 || x >= 127488 && x <= 127490 || x >= 127504 && x <= 127547 || x >= 127552 && x <= 127560 || x === 127568 || x === 127569 || x >= 127584 && x <= 127589 || x >= 127744 && x <= 127776 || x >= 127789 && x <= 127797 || x >= 127799 && x <= 127868 || x >= 127870 && x <= 127891 || x >= 127904 && x <= 127946 || x >= 127951 && x <= 127955 || x >= 127968 && x <= 127984 || x === 127988 || x >= 127992 && x <= 128062 || x === 128064 || x >= 128066 && x <= 128252 || x >= 128255 && x <= 128317 || x >= 128331 && x <= 128334 || x >= 128336 && x <= 128359 || x === 128378 || x === 128405 || x === 128406 || x === 128420 || x >= 128507 && x <= 128591 || x >= 128640 && x <= 128709 || x === 128716 || x >= 128720 && x <= 128722 || x >= 128725 && x <= 128727 || x >= 128732 && x <= 128735 || x === 128747 || x === 128748 || x >= 128756 && x <= 128764 || x >= 128992 && x <= 129003 || x === 129008 || x >= 129292 && x <= 129338 || x >= 129340 && x <= 129349 || x >= 129351 && x <= 129535 || x >= 129648 && x <= 129660 || x >= 129664 && x <= 129672 || x >= 129680 && x <= 129725 || x >= 129727 && x <= 129733 || x >= 129742 && x <= 129755 || x >= 129760 && x <= 129768 || x >= 129776 && x <= 129784 || x >= 131072 && x <= 196605 || x >= 196608 && x <= 262141;
    };
  }
});

// node_modules/fast-string-truncated-width/dist/index.js
var ANSI_RE, CONTROL_RE, TAB_RE, EMOJI_RE, LATIN_RE, MODIFIER_RE, NO_TRUNCATION, getStringTruncatedWidth, dist_default7;
var init_dist7 = __esm({
  "node_modules/fast-string-truncated-width/dist/index.js"() {
    init_utils5();
    ANSI_RE = /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/y;
    CONTROL_RE = /[\x00-\x08\x0A-\x1F\x7F-\x9F]{1,1000}/y;
    TAB_RE = /\t{1,1000}/y;
    EMOJI_RE = /[\u{1F1E6}-\u{1F1FF}]{2}|\u{1F3F4}[\u{E0061}-\u{E007A}]{2}[\u{E0030}-\u{E0039}\u{E0061}-\u{E007A}]{1,3}\u{E007F}|(?:\p{Emoji}\uFE0F\u20E3?|\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation})(?:\u200D(?:\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation}|\p{Emoji}\uFE0F\u20E3?))*/yu;
    LATIN_RE = /(?:[\x20-\x7E\xA0-\xFF](?!\uFE0F)){1,1000}/y;
    MODIFIER_RE = /\p{M}+/gu;
    NO_TRUNCATION = { limit: Infinity, ellipsis: "" };
    getStringTruncatedWidth = (input, truncationOptions = {}, widthOptions = {}) => {
      const LIMIT = truncationOptions.limit ?? Infinity;
      const ELLIPSIS2 = truncationOptions.ellipsis ?? "";
      const ELLIPSIS_WIDTH2 = (truncationOptions == null ? void 0 : truncationOptions.ellipsisWidth) ?? (ELLIPSIS2 ? getStringTruncatedWidth(ELLIPSIS2, NO_TRUNCATION, widthOptions).width : 0);
      const ANSI_WIDTH = widthOptions.ansiWidth ?? 0;
      const CONTROL_WIDTH = widthOptions.controlWidth ?? 0;
      const TAB_WIDTH = widthOptions.tabWidth ?? 8;
      const AMBIGUOUS_WIDTH = widthOptions.ambiguousWidth ?? 1;
      const EMOJI_WIDTH = widthOptions.emojiWidth ?? 2;
      const FULL_WIDTH_WIDTH = widthOptions.fullWidthWidth ?? 2;
      const REGULAR_WIDTH = widthOptions.regularWidth ?? 1;
      const WIDE_WIDTH = widthOptions.wideWidth ?? 2;
      let indexPrev = 0;
      let index = 0;
      let length = input.length;
      let lengthExtra = 0;
      let truncationEnabled = false;
      let truncationIndex = length;
      let truncationLimit = Math.max(0, LIMIT - ELLIPSIS_WIDTH2);
      let unmatchedStart = 0;
      let unmatchedEnd = 0;
      let width = 0;
      let widthExtra = 0;
      outer: while (true) {
        if (unmatchedEnd > unmatchedStart || index >= length && index > indexPrev) {
          const unmatched = input.slice(unmatchedStart, unmatchedEnd) || input.slice(indexPrev, index);
          lengthExtra = 0;
          for (const char of unmatched.replaceAll(MODIFIER_RE, "")) {
            const codePoint = char.codePointAt(0) || 0;
            if (isFullWidth(codePoint)) {
              widthExtra = FULL_WIDTH_WIDTH;
            } else if (isWide(codePoint)) {
              widthExtra = WIDE_WIDTH;
            } else if (AMBIGUOUS_WIDTH !== REGULAR_WIDTH && isAmbiguous(codePoint)) {
              widthExtra = AMBIGUOUS_WIDTH;
            } else {
              widthExtra = REGULAR_WIDTH;
            }
            if (width + widthExtra > truncationLimit) {
              truncationIndex = Math.min(truncationIndex, Math.max(unmatchedStart, indexPrev) + lengthExtra);
            }
            if (width + widthExtra > LIMIT) {
              truncationEnabled = true;
              break outer;
            }
            lengthExtra += char.length;
            width += widthExtra;
          }
          unmatchedStart = unmatchedEnd = 0;
        }
        if (index >= length)
          break;
        LATIN_RE.lastIndex = index;
        if (LATIN_RE.test(input)) {
          lengthExtra = LATIN_RE.lastIndex - index;
          widthExtra = lengthExtra * REGULAR_WIDTH;
          if (width + widthExtra > truncationLimit) {
            truncationIndex = Math.min(truncationIndex, index + Math.floor((truncationLimit - width) / REGULAR_WIDTH));
          }
          if (width + widthExtra > LIMIT) {
            truncationEnabled = true;
            break;
          }
          width += widthExtra;
          unmatchedStart = indexPrev;
          unmatchedEnd = index;
          index = indexPrev = LATIN_RE.lastIndex;
          continue;
        }
        ANSI_RE.lastIndex = index;
        if (ANSI_RE.test(input)) {
          if (width + ANSI_WIDTH > truncationLimit) {
            truncationIndex = Math.min(truncationIndex, index);
          }
          if (width + ANSI_WIDTH > LIMIT) {
            truncationEnabled = true;
            break;
          }
          width += ANSI_WIDTH;
          unmatchedStart = indexPrev;
          unmatchedEnd = index;
          index = indexPrev = ANSI_RE.lastIndex;
          continue;
        }
        CONTROL_RE.lastIndex = index;
        if (CONTROL_RE.test(input)) {
          lengthExtra = CONTROL_RE.lastIndex - index;
          widthExtra = lengthExtra * CONTROL_WIDTH;
          if (width + widthExtra > truncationLimit) {
            truncationIndex = Math.min(truncationIndex, index + Math.floor((truncationLimit - width) / CONTROL_WIDTH));
          }
          if (width + widthExtra > LIMIT) {
            truncationEnabled = true;
            break;
          }
          width += widthExtra;
          unmatchedStart = indexPrev;
          unmatchedEnd = index;
          index = indexPrev = CONTROL_RE.lastIndex;
          continue;
        }
        TAB_RE.lastIndex = index;
        if (TAB_RE.test(input)) {
          lengthExtra = TAB_RE.lastIndex - index;
          widthExtra = lengthExtra * TAB_WIDTH;
          if (width + widthExtra > truncationLimit) {
            truncationIndex = Math.min(truncationIndex, index + Math.floor((truncationLimit - width) / TAB_WIDTH));
          }
          if (width + widthExtra > LIMIT) {
            truncationEnabled = true;
            break;
          }
          width += widthExtra;
          unmatchedStart = indexPrev;
          unmatchedEnd = index;
          index = indexPrev = TAB_RE.lastIndex;
          continue;
        }
        EMOJI_RE.lastIndex = index;
        if (EMOJI_RE.test(input)) {
          if (width + EMOJI_WIDTH > truncationLimit) {
            truncationIndex = Math.min(truncationIndex, index);
          }
          if (width + EMOJI_WIDTH > LIMIT) {
            truncationEnabled = true;
            break;
          }
          width += EMOJI_WIDTH;
          unmatchedStart = indexPrev;
          unmatchedEnd = index;
          index = indexPrev = EMOJI_RE.lastIndex;
          continue;
        }
        index += 1;
      }
      return {
        width: truncationEnabled ? truncationLimit : width,
        index: truncationEnabled ? truncationIndex : length,
        truncated: truncationEnabled,
        ellipsed: truncationEnabled && LIMIT >= ELLIPSIS_WIDTH2
      };
    };
    dist_default7 = getStringTruncatedWidth;
  }
});

// node_modules/fast-string-width/dist/index.js
var NO_TRUNCATION2, fastStringWidth, dist_default8;
var init_dist8 = __esm({
  "node_modules/fast-string-width/dist/index.js"() {
    init_dist7();
    NO_TRUNCATION2 = {
      limit: Infinity,
      ellipsis: "",
      ellipsisWidth: 0
    };
    fastStringWidth = (input, options = {}) => {
      return dist_default7(input, NO_TRUNCATION2, options).width;
    };
    dist_default8 = fastStringWidth;
  }
});

// node_modules/tiny-bin/dist/objects/addon.js
var Addon, addon_default;
var init_addon = __esm({
  "node_modules/tiny-bin/dist/objects/addon.js"() {
    Addon = class {
      /* CONSTRUCTOR */
      constructor(bin2) {
        this.bin = bin2;
        this.stdout = bin2.stdout;
        this.stderr = bin2.stderr;
      }
    };
    addon_default = Addon;
  }
});

// node_modules/ansi-purge/dist/constants.js
var ANSI_RE2;
var init_constants3 = __esm({
  "node_modules/ansi-purge/dist/constants.js"() {
    ANSI_RE2 = /([\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><])/g;
  }
});

// node_modules/ansi-purge/dist/index.js
var purge, dist_default9;
var init_dist9 = __esm({
  "node_modules/ansi-purge/dist/index.js"() {
    init_constants3();
    purge = (str2) => {
      return str2.replace(ANSI_RE2, "");
    };
    dist_default9 = purge;
  }
});

// node_modules/tiny-levenshtein/dist/matrix.js
var Matrix, matrix_default;
var init_matrix = __esm({
  "node_modules/tiny-levenshtein/dist/matrix.js"() {
    Matrix = class {
      /* CONSTRUCTOR */
      constructor(rows, columns, Buffer3 = Uint32Array) {
        this.rows = rows;
        this.columns = columns;
        this.buffer = new Buffer3(this.rows * this.columns);
      }
      /* API */
      get(row, column2) {
        const index = row * this.columns + column2;
        return this.buffer[index];
      }
      set(row, column2, value) {
        const index = row * this.columns + column2;
        return this.buffer[index] = value;
      }
    };
    matrix_default = Matrix;
  }
});

// node_modules/tiny-levenshtein/dist/index.js
var levenshtein, dist_default10;
var init_dist10 = __esm({
  "node_modules/tiny-levenshtein/dist/index.js"() {
    init_matrix();
    levenshtein = (a, b) => {
      if (a === b)
        return 0;
      let start = 0;
      let aEnd = a.length - 1;
      let bEnd = b.length - 1;
      while (start <= aEnd && start <= bEnd) {
        if (a.charCodeAt(start) !== b.charCodeAt(start))
          break;
        start += 1;
      }
      while (aEnd >= start && bEnd >= start) {
        if (a.charCodeAt(aEnd) !== b.charCodeAt(bEnd))
          break;
        aEnd -= 1;
        bEnd -= 1;
      }
      const aLength = aEnd - start + 1;
      const bLength = bEnd - start + 1;
      if (!aLength)
        return bLength;
      if (!bLength)
        return aLength;
      const maxDistance = Math.max(aLength, bLength);
      const Buffer3 = maxDistance < 255 ? Uint8Array : maxDistance < 65535 ? Uint16Array : Uint32Array;
      const matrix = new matrix_default(aLength + 1, bLength + 1, Buffer3);
      for (let i = 1, l = aLength; i <= l; i++) {
        matrix.set(i, 0, i);
      }
      for (let i = 1, l = bLength; i <= l; i++) {
        matrix.set(0, i, i);
      }
      for (let i = 1; i <= aLength; i++) {
        for (let j = 1; j <= bLength; j++) {
          const cost = a.charCodeAt(start + i - 1) === b.charCodeAt(start + j - 1) ? 0 : 1;
          const deletion = matrix.get(i - 1, j) + 1;
          const insertion = matrix.get(i, j - 1) + 1;
          const substitution = matrix.get(i - 1, j - 1) + cost;
          const value = Math.min(deletion, insertion, substitution);
          matrix.set(i, j, value);
        }
      }
      const distance = matrix.get(aLength, bLength);
      return distance;
    };
    dist_default10 = levenshtein;
  }
});

// node_modules/tiny-bin/dist/utils.js
var camelCase, castArray2, defer, getClosest, groupBy, identity, isArray, isUndefined2, pushBack, sum;
var init_utils6 = __esm({
  "node_modules/tiny-bin/dist/utils.js"() {
    init_dist9();
    init_dist10();
    camelCase = /* @__PURE__ */ (() => {
      const dividerRe = /[_.\s-]+/g;
      const prefixRe = /^[_.\s-]+/g;
      const upperDigitRe = /\d+[\p{Alpha}\p{N}_]/gu;
      const upperDividerRe = /[_.\s-]+[\p{Alpha}\p{N}_]/gu;
      const toUpperCase = (str2) => str2.toUpperCase();
      return (str2) => {
        return str2.trim().toLowerCase().replace(prefixRe, "").replace(upperDigitRe, toUpperCase).replace(upperDividerRe, toUpperCase).replace(dividerRe, "");
      };
    })();
    castArray2 = (value) => {
      return Array.isArray(value) ? value : [value];
    };
    defer = (fn) => {
      setTimeout(fn, 0);
    };
    getClosest = (values, value, maxDistance = 3, caseInsensitive = false) => {
      if (!values.length)
        return;
      const target = caseInsensitive ? value.toLowerCase() : value;
      const targets = caseInsensitive ? values.map((value2) => value2.toLowerCase()) : values;
      const distances = targets.map((other) => dist_default10(target, other));
      const minDistance = Math.min(...distances);
      if (minDistance > maxDistance)
        return;
      const minDistanceIndex = distances.indexOf(minDistance);
      const closest = values[minDistanceIndex];
      return closest;
    };
    groupBy = (values, iterator) => {
      const groups = /* @__PURE__ */ new Map();
      for (let i = 0, l = values.length; i < l; i++) {
        const value = values[i];
        const key2 = iterator(value, i, values);
        const group = groups.get(key2) || [];
        group.push(value);
        groups.set(key2, group);
      }
      return groups;
    };
    identity = (value) => {
      return value;
    };
    isArray = (value) => {
      return Array.isArray(value);
    };
    isUndefined2 = (value) => {
      return value === void 0;
    };
    pushBack = (map2, key2) => {
      const value = map2.get(key2);
      if (isUndefined2(value))
        return map2;
      map2.delete(key2);
      map2.set(key2, value);
      return map2;
    };
    sum = (numbers) => {
      return numbers.reduce((acc, value) => acc + value, 0);
    };
  }
});

// node_modules/tiny-bin/dist/objects/logger.js
var Logger, logger_default;
var init_logger = __esm({
  "node_modules/tiny-bin/dist/objects/logger.js"() {
    init_dist8();
    init_dist4();
    init_addon();
    init_utils6();
    Logger = class extends addon_default {
      /* CONSTRUCTOR */
      constructor(bin2, handler) {
        super(bin2);
        this.indentationLevel = 0;
        this.indentation = "  ";
        this.handler = handler;
      }
      /* API */
      indent() {
        this.indentationLevel += 1;
      }
      dedent() {
        this.indentationLevel -= 1;
      }
      group(name, fn) {
        this.print(dist_default4.bold(name.toUpperCase()));
        this.indent();
        this.print();
        fn();
        this.print();
        this.dedent();
      }
      print(message = "") {
        const colorize = this.bin.metadata.colors ? identity : dist_default9;
        this.handler(colorize(`${this.indentation.repeat(this.indentationLevel)}${message}`));
      }
      table(rows, mode = "line") {
        const rowsLengths = rows.map((row) => row.map((cell) => dist_default8(cell)));
        const maxLengths = rowsLengths[0].map((_, j) => Math.max(...rowsLengths.map((_2, i) => rowsLengths[i][j])));
        if (mode === "lines" && maxLengths.length === 2) {
          const COLUMN = 30;
          const PADDING = 4;
          rows.forEach(([left, right], i) => {
            const leftNedded = dist_default8(left) + PADDING;
            const leftAvailable = COLUMN - leftNedded;
            const leftShortEnough = leftAvailable >= 2;
            const rightLines = right.trim().split(/\r?\n|\r/g);
            const line2 = [left, rightLines.map((line3, i2) => leftShortEnough && !i2 ? `${" ".repeat(leftAvailable)}${line3}` : `${i2 ? "" : "\n"}${" ".repeat(COLUMN)}${line3}`).join("\n")].join("");
            this.print(line2);
          });
        } else if (mode === "line") {
          rows.forEach((row, i) => {
            const line2 = row.map((value, j) => {
              const paddingLength = j === row.length - 1 ? 0 : Math.max(0, 1 + maxLengths[j] - rowsLengths[i][j]);
              const padding = " ".repeat(paddingLength);
              return `${value}${padding}`;
            }).join(" ");
            this.print(line2);
          });
        } else {
          throw new Error("Unsupported printing mode");
        }
      }
    };
    logger_default = Logger;
  }
});

// node_modules/tiny-bin/dist/objects/metadata.js
var Metadata, metadata_default;
var init_metadata = __esm({
  "node_modules/tiny-bin/dist/objects/metadata.js"() {
    init_dist4();
    init_addon();
    Metadata = class extends addon_default {
      constructor() {
        super(...arguments);
        this.name = "bin";
        this.description = "";
        this.package = "";
        this.version = "0.0.0";
        this.colors = true;
        this.exiter = true;
        this.updater = true;
      }
      /* API */
      print() {
        this.stdout.print(`${dist_default4.cyan(this.name)} ${dist_default4.dim(this.version)}`);
        this.stdout.print();
      }
    };
    metadata_default = Metadata;
  }
});

// node_modules/tiny-bin/dist/objects/collection.js
var Collection, collection_default;
var init_collection = __esm({
  "node_modules/tiny-bin/dist/objects/collection.js"() {
    init_addon();
    init_utils6();
    Collection = class extends addon_default {
      constructor() {
        super(...arguments);
        this.list = [];
        this.map = /* @__PURE__ */ new Map();
      }
      /* API */
      getAll() {
        return this.list;
      }
      getById(id) {
        var _a4;
        return (_a4 = this.getByIds([id])) == null ? void 0 : _a4.value;
      }
      getByIdOrFail(id) {
        const value = this.getById(id);
        if (value)
          return value;
        const ids = Array.from(this.map.keys());
        const closest = getClosest(ids, id, 3, true);
        this.bin.fail(`Not found "${id}"${closest ? `. Did you mean "${closest}"?` : ""}`);
      }
      getByIds(ids) {
        for (const id of ids) {
          const value = this.map.get(id);
          if (value)
            return { id, value };
        }
      }
      register(value, override = false) {
        const existing = this.getByIds(value.ids);
        if (existing && override) {
          const index = this.list.indexOf(existing.value);
          existing.value.ids.forEach((id) => this.map.delete(id));
          value.ids.forEach((id) => this.map.set(id, value));
          this.list.splice(index, 1, value);
        } else {
          value.ids.forEach((id) => this.map.set(id, value));
          this.list.push(value);
        }
      }
    };
    collection_default = Collection;
  }
});

// node_modules/tiny-bin/dist/objects/commands.js
var Commands, commands_default;
var init_commands = __esm({
  "node_modules/tiny-bin/dist/objects/commands.js"() {
    init_dist4();
    init_collection();
    init_utils6();
    Commands = class extends collection_default {
      /* API */
      print(mode) {
        const commands = this.getAll();
        if (!commands.length)
          return;
        const commandsVisible = commands.filter((command) => !command.hidden);
        if (!commandsVisible.length)
          return;
        const withoutOther = (section) => section.toLowerCase() !== "other" ? section : "";
        const commandsBySection = pushBack(groupBy(commandsVisible, (command) => withoutOther(command.section.toLowerCase())), "");
        commandsBySection.forEach((commands2, section) => {
          if (!commands2.length)
            return;
          const title = section ? `${section.toUpperCase()} COMMANDS` : commandsBySection.size > 1 ? "OTHER COMMANDS" : "COMMANDS";
          const table = commands2.map((command) => {
            const withDeprecated = command.deprecated ? dist_default4.dim : identity;
            return [
              [
                dist_default4.magenta(command.name),
                ...command.arguments.getAll().map((arg) => dist_default4.yellow(arg.name))
              ].join(" "),
              command.description
            ].map(withDeprecated);
          });
          this.stdout.group(title, () => {
            this.stdout.table(table, mode);
          });
        });
      }
      run(name, options, argv) {
        const command = this.getByIdOrFail(name);
        return command.run(options, argv);
      }
    };
    commands_default = Commands;
  }
});

// node_modules/tiny-bin/dist/objects/arguments.js
var Arguments, arguments_default;
var init_arguments = __esm({
  "node_modules/tiny-bin/dist/objects/arguments.js"() {
    init_dist4();
    init_collection();
    Arguments = class extends collection_default {
      /* API */
      print(mode) {
        const args = this.getAll();
        if (!args.length)
          return;
        const table = args.map((arg) => [
          dist_default4.yellow(arg.name),
          arg.description
        ]);
        this.stdout.group("ARGUMENTS", () => {
          this.stdout.table(table, mode);
        });
      }
    };
    arguments_default = Arguments;
  }
});

// node_modules/tiny-bin/dist/objects/options.js
var Options, options_default;
var init_options = __esm({
  "node_modules/tiny-bin/dist/objects/options.js"() {
    init_dist4();
    init_collection();
    init_utils6();
    Options = class extends collection_default {
      /* API */
      print(mode) {
        const options = this.getAll();
        if (!options.length)
          return;
        const optionsVisible = options.filter((option) => !option.hidden);
        if (!optionsVisible.length)
          return;
        const withoutOther = (section) => section.toLowerCase() !== "other" ? section : "";
        const optionsBySection = pushBack(groupBy(optionsVisible, (option) => withoutOther(option.section.toLowerCase())), "");
        optionsBySection.forEach((options2, section) => {
          if (!options2.length)
            return;
          const title = section ? `${section.toUpperCase()} OPTIONS` : optionsBySection.size > 1 ? "OTHER OPTIONS" : "OPTIONS";
          const table = options2.map((option) => {
            const withDeprecated = option.deprecated ? dist_default4.dim : identity;
            return [
              [
                [
                  ...option.data.longs.sort().map((long) => dist_default4.green(`--${long}`)),
                  ...option.data.shorts.sort().map((short) => dist_default4.green(`-${short}`))
                ].join(", "),
                [
                  ...option.data.args.sort().map((arg) => dist_default4.blue(`<${arg}>`))
                ].join(" ")
              ].join(" "),
              option.description
            ].map(withDeprecated);
          });
          this.stdout.group(title, () => {
            this.stdout.table(table, mode);
          });
        });
      }
    };
    options_default = Options;
  }
});

// node_modules/tiny-bin/dist/objects/usage.js
var Usage, usage_default;
var init_usage = __esm({
  "node_modules/tiny-bin/dist/objects/usage.js"() {
    init_dist4();
    init_addon();
    init_utils6();
    Usage = class extends addon_default {
      constructor() {
        super(...arguments);
        this.usages = /* @__PURE__ */ new Set();
      }
      /* API */
      print(command) {
        this.stdout.group("USAGE", () => {
          if (this.usages.size) {
            this.usages.forEach((usage) => {
              this.stdout.print(usage);
            });
          } else {
            const isCommandDefault = command === this.bin.command;
            const binName = this.bin.metadata.name;
            const commandName = isCommandDefault ? "" : command.name;
            const name = [binName, commandName].filter(identity).join(" ");
            const commands = isCommandDefault && !command.handler ? dist_default4.magenta("[command]") : "";
            const args = command.arguments.getAll().map((arg) => dist_default4.yellow(arg.name)).join(" ");
            const line2 = [name, commands, args].filter(identity).join(" ");
            this.stdout.print(line2);
          }
        });
      }
      register(usage) {
        this.usages.add(usage);
      }
    };
    usage_default = Usage;
  }
});

// node_modules/tiny-bin/dist/objects/command.js
var Command, command_default;
var init_command = __esm({
  "node_modules/tiny-bin/dist/objects/command.js"() {
    init_addon();
    init_arguments();
    init_options();
    init_usage();
    Command = class extends addon_default {
      /* CONSTRUCTOR */
      constructor(bin2, options) {
        super(bin2);
        this.arguments = new arguments_default(this.bin);
        this.options = new options_default(this.bin);
        this.usage = new usage_default(this.bin);
        this.ids = [this.parse(options.name)];
        this.name = options.name;
        this.description = options.description;
        this.section = options.section || "";
        this.deprecated = !!options.deprecated;
        this.hidden = !!options.hidden;
      }
      /* PRIVATE API */
      parse(name) {
        const re = /^_?[a-z][a-z-]*$/;
        const isValid = re.test(name);
        if (!isValid)
          this.bin.fail(`Invalid command: "${name}"`);
        return name;
      }
      /* API */
      async run(options, argv) {
        if (!this.handler) {
          this.bin.fail(`Command handler not defined for command: "${this.name}"`);
        } else {
          return this.handler(options, options._, options["--"]);
        }
      }
    };
    command_default = Command;
  }
});

// node_modules/tiny-bin/dist/objects/command_default.js
var CommandDefault, command_default_default;
var init_command_default = __esm({
  "node_modules/tiny-bin/dist/objects/command_default.js"() {
    init_dist5();
    init_command();
    init_utils6();
    CommandDefault = class extends command_default {
      /* CONSTRUCTOR */
      constructor(bin2) {
        super(bin2, {
          name: "_default",
          description: "Execute the default action",
          hidden: true
        });
      }
      /* API */
      async run(options, argv) {
        const name = this.bin.commands.getById(options._[0]) ? options._[0] : this.name;
        if (options["help"] || name === "help") {
          return this.bin.commands.run("help", options, argv);
        } else if (options["version"] || options["v"]) {
          return this.bin.commands.run("_version", options, argv);
        } else {
          const isDefault = name === this.name;
          if (isDefault && !this.handler) {
            this.bin.fail("Command handler not defined for default command");
          }
          const command = this.bin.commands.getByIdOrFail(name);
          const options2 = [...this.bin.command.options.getAll(), ...command.options.getAll()];
          const minArgs = command.arguments.getAll().filter((arg) => arg.required).length;
          const maxArgs = sum(command.arguments.getAll().map((arg) => arg.variadic ? Infinity : 1));
          const parseArgvOptions = {
            known: [],
            boolean: [],
            integer: [],
            number: [],
            string: [],
            eager: [],
            required: [],
            unary: [],
            variadic: [],
            alias: {},
            default: {},
            incompatible: {},
            validators: {},
            onIncompatible: (options3) => {
              this.bin.fail(`Incompatible options: "${options3[0][0]}" and "${options3[0][1]}" cannot be used together`);
            },
            onInvalid: (options3) => {
              this.bin.fail(`Invalid value for "${options3[0]}" option`);
            },
            onMissing: (options3) => {
              this.bin.fail(`Missing required option: "${options3[0]}"`);
            },
            onUnknown: (options3) => {
              const closest = getClosest(parseArgvOptions.known, options3[0], 3, true);
              this.bin.fail(`Unknown option: "${options3[0]}"${closest ? `. Did you mean "${closest}"?` : ""}`);
            }
          };
          options2.forEach((option) => {
            var _a4, _b2;
            parseArgvOptions.known.push(...option.data.alls);
            if (option.data.type === "boolean") {
              parseArgvOptions.boolean.push(...option.data.alls);
            }
            if (option.data.type === "integer") {
              parseArgvOptions.integer.push(...option.data.alls);
            }
            if (option.data.type === "number") {
              parseArgvOptions.number.push(...option.data.alls);
            }
            if (option.data.type === "string") {
              parseArgvOptions.string.push(...option.data.alls);
            }
            if (option.eager) {
              parseArgvOptions.eager.push(...option.data.alls);
            }
            if (option.incompatible) {
              const incompatible = (_a4 = parseArgvOptions.incompatible)[_b2 = option.data.alls[0]] || (_a4[_b2] = []);
              incompatible.push(...option.incompatible);
            }
            if (option.required) {
              parseArgvOptions.required.push(...option.data.alls);
            }
            if (!option.variadic) {
              parseArgvOptions.unary.push(...option.data.alls);
            }
            if (option.variadic) {
              parseArgvOptions.variadic.push(...option.data.alls);
            }
            if (option.validate) {
              parseArgvOptions.validators[option.data.alls[0]] = option.validate;
            }
            if ("default" in option) {
              parseArgvOptions.default[option.data.alls[0]] = option.default;
            }
            const [first, ...rest] = option.data.alls;
            parseArgvOptions.alias[first] = rest;
          });
          const parsed = dist_default5(argv, parseArgvOptions);
          options2.forEach((option) => {
            if (option.data.type !== "string")
              return;
            const name2 = option.data.alls[0];
            const value = parsed[name2];
            if (!value)
              return;
            const enums = option.enum;
            if (!enums)
              return;
            const values = castArray2(value);
            values.forEach((value2) => {
              if (enums.includes(value2))
                return;
              this.bin.fail(`Invalid value for "${option.data.alls[0]}" option, received "${value2}" but only ${enums.map((e) => `"${e}"`).join(", ")} are supported`);
            });
          });
          options2.forEach((option) => {
            const name2 = option.data.alls[0];
            const value = parsed[name2];
            if (!isArray(value))
              return;
            if (value.length < 2)
              return;
            if (option.variadic)
              return;
            this.bin.fail(`Expected 1 value for "${option.data.alls[0]}" option, but received "${value.length}" values`);
          });
          Object.keys(parsed).forEach((key2) => {
            const camelKey = camelCase(key2);
            if (camelKey === key2)
              return;
            parsed[camelKey] = parsed[key2];
          });
          if (!isDefault) {
            parsed._.shift();
          }
          const actualArgs = parsed._.length;
          if (actualArgs < minArgs || actualArgs > maxArgs) {
            if (minArgs === maxArgs) {
              this.bin.fail(`Expected ${minArgs} arguments, but received ${actualArgs} arguments`);
            } else {
              this.bin.fail(`Expected between ${minArgs} and ${maxArgs} arguments, but received ${actualArgs} arguments`);
            }
          }
          if (isDefault) {
            return this.handler(parsed, parsed._, parsed["--"]);
          } else {
            return command.run(parsed, argv);
          }
        }
      }
    };
    command_default_default = CommandDefault;
  }
});

// node_modules/tiny-bin/dist/objects/argument.js
var Argument, argument_default;
var init_argument = __esm({
  "node_modules/tiny-bin/dist/objects/argument.js"() {
    init_addon();
    Argument = class extends addon_default {
      /* CONSTRUCTOR */
      constructor(bin2, options) {
        super(bin2);
        this.ids = [this.parse(options.name)];
        this.name = options.name;
        this.description = options.description;
        this.required = options.name[0] === "<";
        this.variadic = options.name.includes("...");
      }
      /* PRIVATE API */
      parse(name) {
        const re = /^\[([^\].]+)(?:\.\.\.)?\]$|^<([^>.]+)(?:\.\.\.)?>$/;
        const match2 = re.exec(name);
        if (!match2)
          this.bin.fail(`Invalid argument: "${name}"`);
        const id = match2[1] || match2[2];
        return id;
      }
    };
    argument_default = Argument;
  }
});

// node_modules/tiny-bin/dist/objects/command_help.js
var CommandHelp, command_help_default;
var init_command_help = __esm({
  "node_modules/tiny-bin/dist/objects/command_help.js"() {
    init_collection();
    init_command();
    init_argument();
    CommandHelp = class extends command_default {
      /* CONSTRUCTOR */
      constructor(bin2) {
        super(bin2, {
          name: "help",
          description: "Display help for the command"
        });
        this.arguments.register(new argument_default(bin2, { name: "[command]", description: "The command to display help for" }));
      }
      /* PRIVATE API */
      getPrintMode(collections) {
        return collections.some((collection) => collection.getAll().some((item) => item.description.includes("\n"))) ? "lines" : "line";
      }
      /* API */
      async run(options, argv) {
        const [arg1, arg2] = options._;
        const hasCustomCommands = this.bin.commands.getAll().length > 3;
        const name = arg1 === "help" ? arg2 || (options["help"] ? arg1 : "") : hasCustomCommands ? arg1 : "";
        if (name) {
          const command = this.bin.commands.getByIdOrFail(name);
          const mode = this.getPrintMode([command.arguments, command.options, this.bin.command.options]);
          this.stdout.indent();
          this.stdout.print();
          this.bin.metadata.print();
          command.usage.print(command);
          command.arguments.print(mode);
          this.bin.command.options.print(mode);
          command.options.print(mode);
          this.stdout.dedent();
        } else {
          const mode = this.getPrintMode([this.bin.command.arguments, this.bin.command.options, this.bin.commands]);
          this.stdout.indent();
          this.stdout.print();
          this.bin.metadata.print();
          this.bin.command.usage.print(this.bin.command);
          this.bin.command.arguments.print(mode);
          this.bin.command.options.print(mode);
          if (hasCustomCommands) {
            this.bin.commands.print(mode);
          }
          this.stdout.dedent();
        }
      }
    };
    command_help_default = CommandHelp;
  }
});

// node_modules/tiny-bin/dist/objects/command_version.js
var CommandVersion, command_version_default;
var init_command_version = __esm({
  "node_modules/tiny-bin/dist/objects/command_version.js"() {
    init_command();
    CommandVersion = class extends command_default {
      /* CONSTRUCTOR */
      constructor(bin2) {
        super(bin2, {
          name: "_version",
          description: "Display the version number",
          hidden: true
        });
      }
      /* API */
      async run(options, argv) {
        this.stdout.print(this.bin.metadata.version);
      }
    };
    command_version_default = CommandVersion;
  }
});

// node_modules/tiny-bin/dist/objects/option.js
var Option, option_default;
var init_option = __esm({
  "node_modules/tiny-bin/dist/objects/option.js"() {
    init_addon();
    init_utils6();
    Option = class extends addon_default {
      /* CONSTRUCTOR */
      constructor(bin2, options) {
        super(bin2);
        this.data = this.parse(options.name, options.type);
        this.ids = this.data.alls;
        this.name = options.name;
        this.description = options.description;
        this.section = options.section || "";
        this.deprecated = !!options.deprecated;
        this.eager = !!options.eager;
        this.hidden = !!options.hidden;
        this.incompatible = castArray2(options.incompatible || []);
        this.required = !!options.required;
        this.variadic = options.name.includes("...");
        this.default = options.default;
        this.enum = options.enum;
        this.validate = options.validate;
        if (this.eager && !this.data.args.length) {
          this.bin.fail(`Eager option must not be boolean: "${this.name}"`);
        }
        if (this.eager && !this.variadic) {
          this.bin.fail(`Eager option must be variadic: "${this.name}"`);
        }
      }
      /* PRIVATE API */
      parse(name, forceType) {
        const longsPositive = [];
        const longs = [];
        const shorts = [];
        const args = [];
        const re = /--([a-z0-9-\.]+)|-([a-zA-Z\.])|<([^>.]+(?:\.\.\.)?)>|([\s,])|([^])/g;
        name.replace(re, (_, long, short, arg, spacer, invalid) => {
          if (long && long.startsWith("no-"))
            longsPositive.push(long.slice(3));
          if (long)
            longs.push(long);
          if (short)
            shorts.push(short);
          if (arg)
            args.push(arg);
          if (invalid)
            this.bin.fail(`Invalid option: "${name}"`);
          return _;
        });
        if (!longs.length && !shorts.length)
          this.bin.fail(`Option must define at least a longhand or a shorthand: "${name}"`);
        if (args.length > 1)
          this.bin.fail(`Option can define at most one argument: "${name}"`);
        const type2 = forceType || (args.length ? "string" : "boolean");
        const alls = [...longsPositive, ...longs, ...shorts];
        const data = { type: type2, alls, longs, shorts, args };
        return data;
      }
    };
    option_default = Option;
  }
});

// node_modules/tiny-bin/dist/objects/bin.js
import process7 from "process";
var Bin, bin_default;
var init_bin = __esm({
  "node_modules/tiny-bin/dist/objects/bin.js"() {
    init_dist3();
    init_dist4();
    init_dist5();
    init_dist6();
    init_logger();
    init_metadata();
    init_commands();
    init_command_default();
    init_command_help();
    init_command_version();
    init_option();
    init_utils6();
    Bin = class {
      /* CONSTRUCTOR */
      constructor(options) {
        this.stdout = new logger_default(this, console.log);
        this.stderr = new logger_default(this, console.error);
        this.metadata = new metadata_default(this);
        this.commands = new commands_default(this);
        this.metadata.name = options.name;
        this.metadata.description = options.description;
        const fallback = new command_default_default(this);
        const help = new command_help_default(this);
        const version = new command_version_default(this);
        this.commands.register(fallback);
        this.commands.register(help);
        this.commands.register(version);
        this.command = fallback;
        this.command.options.register(new option_default(this, { name: "--help", description: "Display help for the command" }));
        this.command.options.register(new option_default(this, { name: "--version, -v", description: "Display the version number" }));
        this.command.options.register(new option_default(this, { name: "--no-color, --no-colors", description: "Disable colored output", hidden: true }));
      }
      /* API */
      fail(message) {
        this.stderr.print();
        this.stderr.indent();
        this.stderr.print(dist_default4.red(message));
        this.stderr.dedent();
        this.stderr.print();
        process7.exit(1);
      }
      async run(argv = process7.argv.slice(2)) {
        if (!this.metadata.package) {
          const pkg = dist_default3();
          if (pkg) {
            const { name, version } = pkg;
            this.metadata.package = name;
            this.metadata.version = version;
          }
        }
        if (this.metadata.package && this.metadata.updater) {
          defer(() => {
            dist_default6({
              name: this.metadata.package,
              version: this.metadata.version,
              ttl: 432e5
            });
          });
        }
        try {
          const options = dist_default5(argv);
          await this.commands.run(this.command.name, options, argv);
          if (this.metadata.exiter) {
            process7.exit();
          }
        } catch (error) {
          console.error(error);
          if (this.metadata.exiter) {
            process7.exit(1);
          }
        }
      }
    };
    bin_default = Bin;
  }
});

// node_modules/tiny-bin/dist/objects/chainable_bin_local.js
var ChainableBinAfterCustomCommand, chainable_bin_local_default;
var init_chainable_bin_local = __esm({
  "node_modules/tiny-bin/dist/objects/chainable_bin_local.js"() {
    init_addon();
    init_chainable_bin_global();
    ChainableBinAfterCustomCommand = class extends addon_default {
      /* API */
      command(name, description, options = {}) {
        return new chainable_bin_global_default(this.bin).command(name, description, options);
      }
      run(argv) {
        return new chainable_bin_global_default(this.bin).run(argv);
      }
    };
    chainable_bin_local_default = ChainableBinAfterCustomCommand;
  }
});

// node_modules/tiny-bin/dist/objects/chainable_command.js
var ChainableCommand, chainable_command_default;
var init_chainable_command = __esm({
  "node_modules/tiny-bin/dist/objects/chainable_command.js"() {
    init_addon();
    init_argument();
    init_chainable_bin_local();
    init_option();
    ChainableCommand = class extends addon_default {
      /* CONSTRUCTOR */
      constructor(bin2, command) {
        super(bin2);
        this.command = command;
      }
      /* API */
      usage(usage) {
        this.command.usage.register(usage);
        return this;
      }
      option(name, description, options = {}) {
        const option = new option_default(this.bin, { name, description, ...options });
        this.command.options.register(option, !!options.override);
        return this;
      }
      argument(name, description, options = {}) {
        const argument = new argument_default(this.bin, { name, description, ...options });
        this.command.arguments.register(argument);
        return this;
      }
      action(handler) {
        this.command.handler = handler;
        return new chainable_bin_local_default(this.bin);
      }
    };
    chainable_command_default = ChainableCommand;
  }
});

// node_modules/tiny-bin/dist/objects/chainable_bin_global.js
var ChainableBin, chainable_bin_global_default;
var init_chainable_bin_global = __esm({
  "node_modules/tiny-bin/dist/objects/chainable_bin_global.js"() {
    init_addon();
    init_argument();
    init_chainable_command();
    init_command();
    init_option();
    ChainableBin = class extends addon_default {
      /* API */
      colors(colors2) {
        this.bin.metadata.colors = colors2;
        return this;
      }
      package(name, version) {
        this.bin.metadata.package = name;
        this.bin.metadata.version = version;
        return this;
      }
      autoExit(exiter) {
        this.bin.metadata.exiter = exiter;
        return this;
      }
      autoUpdateNotifier(updater2) {
        this.bin.metadata.updater = updater2;
        return this;
      }
      usage(usage) {
        this.bin.command.usage.register(usage);
        return this;
      }
      option(name, description, options = {}) {
        const option = new option_default(this.bin, { name, description, ...options });
        this.bin.command.options.register(option, !!options.override);
        return this;
      }
      argument(name, description, options = {}) {
        const argument = new argument_default(this.bin, { name, description, ...options });
        this.bin.command.arguments.register(argument);
        return this;
      }
      action(handler) {
        this.bin.command.handler = handler;
        return this;
      }
      command(name, description, options = {}) {
        const command = new command_default(this.bin, { name, description, ...options });
        this.bin.commands.register(command);
        return new chainable_command_default(this.bin, command);
      }
      run(argv) {
        return this.bin.run(argv);
      }
    };
    chainable_bin_global_default = ChainableBin;
  }
});

// node_modules/tiny-bin/dist/index.js
var bin, dist_default11;
var init_dist11 = __esm({
  "node_modules/tiny-bin/dist/index.js"() {
    init_bin();
    init_chainable_bin_global();
    bin = (name, description) => {
      const bin2 = new bin_default({ name, description });
      const chainable = new chainable_bin_global_default(bin2);
      return chainable;
    };
    dist_default11 = bin;
  }
});

// node_modules/specialist/dist/exit.js
import process8 from "process";
var exit, exit_default;
var init_exit = __esm({
  "node_modules/specialist/dist/exit.js"() {
    init_dist4();
    exit = (message, code = 1) => {
      const log = code === 0 ? console.log : console.error;
      if (code === 0) {
        log(message);
      } else {
        log(`
  ${dist_default4.red(message)}
`);
      }
      process8.exit(code);
    };
    exit_default = exit;
  }
});

// node_modules/specialist/dist/index.js
var init_dist12 = __esm({
  "node_modules/specialist/dist/index.js"() {
    init_dist11();
    init_dist4();
    init_dist5();
    init_dist6();
    init_exit();
  }
});

// src/experimental-cli/constants.evaluate.js
var CLI_VERSION, DEFAULT_PARSERS, PRETTIER_VERSION;
var init_constants_evaluate = __esm({
  "src/experimental-cli/constants.evaluate.js"() {
    CLI_VERSION = "0.9.0";
    DEFAULT_PARSERS = [
      "flow",
      "babel",
      "babel-flow",
      "babel-ts",
      "typescript",
      "acorn",
      "espree",
      "meriyah",
      "css",
      "less",
      "scss",
      "json",
      "json5",
      "jsonc",
      "json-stringify",
      "graphql",
      "markdown",
      "mdx",
      "vue",
      "yaml",
      "glimmer",
      "html",
      "angular",
      "lwc"
    ];
    PRETTIER_VERSION = "3.6.2";
  }
});

// node_modules/function-once/dist/index.js
var once, dist_default12;
var init_dist13 = __esm({
  "node_modules/function-once/dist/index.js"() {
    once = (fn) => {
      let called = false;
      let result;
      return () => {
        if (!called) {
          called = true;
          result = fn();
        }
        return result;
      };
    };
    dist_default12 = once;
  }
});

// node_modules/import-meta-resolve/lib/errors.js
import v8 from "v8";
import assert from "assert";
import { format, inspect } from "util";
function formatList(array, type2 = "and") {
  return array.length < 3 ? array.join(` ${type2} `) : `${array.slice(0, -1).join(", ")}, ${type2} ${array[array.length - 1]}`;
}
function createError(sym, value, constructor) {
  messages.set(sym, value);
  return makeNodeErrorWithCode(constructor, sym);
}
function makeNodeErrorWithCode(Base, key2) {
  return NodeError;
  function NodeError(...parameters) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
    const error = new Base();
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
    const message = getMessage(key2, parameters, error);
    Object.defineProperties(error, {
      // Note: no need to implement `kIsNodeError` symbol, would be hard,
      // probably.
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      },
      toString: {
        /** @this {Error} */
        value() {
          return `${this.name} [${key2}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    captureLargerStackTrace(error);
    error.code = key2;
    return error;
  }
}
function isErrorStackTraceLimitWritable() {
  try {
    if (v8.startupSnapshot.isBuildingSnapshot()) {
      return false;
    }
  } catch {
  }
  const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc === void 0) {
    return Object.isExtensible(Error);
  }
  return own.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
function hideStackFrames(wrappedFunction) {
  const hidden = nodeInternalPrefix + wrappedFunction.name;
  Object.defineProperty(wrappedFunction, "name", { value: hidden });
  return wrappedFunction;
}
function getMessage(key2, parameters, self) {
  const message = messages.get(key2);
  assert(message !== void 0, "expected `message` to be found");
  if (typeof message === "function") {
    assert(
      message.length <= parameters.length,
      // Default options do not count.
      `Code: ${key2}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`
    );
    return Reflect.apply(message, self, parameters);
  }
  const regex2 = /%[dfijoOs]/g;
  let expectedLength = 0;
  while (regex2.exec(message) !== null) expectedLength++;
  assert(
    expectedLength === parameters.length,
    `Code: ${key2}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`
  );
  if (parameters.length === 0) return message;
  parameters.unshift(message);
  return Reflect.apply(format, null, parameters);
}
function determineSpecificType(value) {
  if (value === null || value === void 0) {
    return String(value);
  }
  if (typeof value === "function" && value.name) {
    return `function ${value.name}`;
  }
  if (typeof value === "object") {
    if (value.constructor && value.constructor.name) {
      return `an instance of ${value.constructor.name}`;
    }
    return `${inspect(value, { depth: -1 })}`;
  }
  let inspected = inspect(value, { colors: false });
  if (inspected.length > 28) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return `type ${typeof value} (${inspected})`;
}
var own, classRegExp, kTypes, codes, messages, nodeInternalPrefix, userStackTraceLimit, captureLargerStackTrace;
var init_errors = __esm({
  "node_modules/import-meta-resolve/lib/errors.js"() {
    own = {}.hasOwnProperty;
    classRegExp = /^([A-Z][a-z\d]*)+$/;
    kTypes = /* @__PURE__ */ new Set([
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ]);
    codes = {};
    messages = /* @__PURE__ */ new Map();
    nodeInternalPrefix = "__node_internal_";
    codes.ERR_INVALID_ARG_TYPE = createError(
      "ERR_INVALID_ARG_TYPE",
      /**
       * @param {string} name
       * @param {Array<string> | string} expected
       * @param {unknown} actual
       */
      (name, expected, actual) => {
        assert(typeof name === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let message = "The ";
        if (name.endsWith(" argument")) {
          message += `${name} `;
        } else {
          const type2 = name.includes(".") ? "property" : "argument";
          message += `"${name}" ${type2} `;
        }
        message += "must be ";
        const types2 = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert(
            typeof value === "string",
            "All expected entries have to be of type string"
          );
          if (kTypes.has(value)) {
            types2.push(value.toLowerCase());
          } else if (classRegExp.exec(value) === null) {
            assert(
              value !== "object",
              'The value "object" should be written as "Object"'
            );
            other.push(value);
          } else {
            instances.push(value);
          }
        }
        if (instances.length > 0) {
          const pos2 = types2.indexOf("object");
          if (pos2 !== -1) {
            types2.slice(pos2, 1);
            instances.push("Object");
          }
        }
        if (types2.length > 0) {
          message += `${types2.length > 1 ? "one of type" : "of type"} ${formatList(
            types2,
            "or"
          )}`;
          if (instances.length > 0 || other.length > 0) message += " or ";
        }
        if (instances.length > 0) {
          message += `an instance of ${formatList(instances, "or")}`;
          if (other.length > 0) message += " or ";
        }
        if (other.length > 0) {
          if (other.length > 1) {
            message += `one of ${formatList(other, "or")}`;
          } else {
            if (other[0].toLowerCase() !== other[0]) message += "an ";
            message += `${other[0]}`;
          }
        }
        message += `. Received ${determineSpecificType(actual)}`;
        return message;
      },
      TypeError
    );
    codes.ERR_INVALID_MODULE_SPECIFIER = createError(
      "ERR_INVALID_MODULE_SPECIFIER",
      /**
       * @param {string} request
       * @param {string} reason
       * @param {string} [base]
       */
      (request, reason, base = void 0) => {
        return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`;
      },
      TypeError
    );
    codes.ERR_INVALID_PACKAGE_CONFIG = createError(
      "ERR_INVALID_PACKAGE_CONFIG",
      /**
       * @param {string} path
       * @param {string} [base]
       * @param {string} [message]
       */
      (path17, base, message) => {
        return `Invalid package config ${path17}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
      },
      Error
    );
    codes.ERR_INVALID_PACKAGE_TARGET = createError(
      "ERR_INVALID_PACKAGE_TARGET",
      /**
       * @param {string} packagePath
       * @param {string} key
       * @param {unknown} target
       * @param {boolean} [isImport=false]
       * @param {string} [base]
       */
      (packagePath, key2, target, isImport = false, base = void 0) => {
        const relatedError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
        if (key2 === ".") {
          assert(isImport === false);
          return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
        }
        return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(
          target
        )} defined for '${key2}' in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
      },
      Error
    );
    codes.ERR_MODULE_NOT_FOUND = createError(
      "ERR_MODULE_NOT_FOUND",
      /**
       * @param {string} path
       * @param {string} base
       * @param {boolean} [exactUrl]
       */
      (path17, base, exactUrl = false) => {
        return `Cannot find ${exactUrl ? "module" : "package"} '${path17}' imported from ${base}`;
      },
      Error
    );
    codes.ERR_NETWORK_IMPORT_DISALLOWED = createError(
      "ERR_NETWORK_IMPORT_DISALLOWED",
      "import of '%s' by %s is not supported: %s",
      Error
    );
    codes.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError(
      "ERR_PACKAGE_IMPORT_NOT_DEFINED",
      /**
       * @param {string} specifier
       * @param {string} packagePath
       * @param {string} base
       */
      (specifier, packagePath, base) => {
        return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`;
      },
      TypeError
    );
    codes.ERR_PACKAGE_PATH_NOT_EXPORTED = createError(
      "ERR_PACKAGE_PATH_NOT_EXPORTED",
      /**
       * @param {string} packagePath
       * @param {string} subpath
       * @param {string} [base]
       */
      (packagePath, subpath, base = void 0) => {
        if (subpath === ".")
          return `No "exports" main defined in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
        return `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
      },
      Error
    );
    codes.ERR_UNSUPPORTED_DIR_IMPORT = createError(
      "ERR_UNSUPPORTED_DIR_IMPORT",
      "Directory import '%s' is not supported resolving ES modules imported from %s",
      Error
    );
    codes.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError(
      "ERR_UNSUPPORTED_RESOLVE_REQUEST",
      'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.',
      TypeError
    );
    codes.ERR_UNKNOWN_FILE_EXTENSION = createError(
      "ERR_UNKNOWN_FILE_EXTENSION",
      /**
       * @param {string} extension
       * @param {string} path
       */
      (extension, path17) => {
        return `Unknown file extension "${extension}" for ${path17}`;
      },
      TypeError
    );
    codes.ERR_INVALID_ARG_VALUE = createError(
      "ERR_INVALID_ARG_VALUE",
      /**
       * @param {string} name
       * @param {unknown} value
       * @param {string} [reason='is invalid']
       */
      (name, value, reason = "is invalid") => {
        let inspected = inspect(value);
        if (inspected.length > 128) {
          inspected = `${inspected.slice(0, 128)}...`;
        }
        const type2 = name.includes(".") ? "property" : "argument";
        return `The ${type2} '${name}' ${reason}. Received ${inspected}`;
      },
      TypeError
      // Note: extra classes have been shaken out.
      // , RangeError
    );
    captureLargerStackTrace = hideStackFrames(
      /**
       * @param {Error} error
       * @returns {Error}
       */
      // @ts-expect-error: fine
      function(error) {
        const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
        if (stackTraceLimitIsWritable) {
          userStackTraceLimit = Error.stackTraceLimit;
          Error.stackTraceLimit = Number.POSITIVE_INFINITY;
        }
        Error.captureStackTrace(error);
        if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
        return error;
      }
    );
  }
});

// node_modules/import-meta-resolve/lib/package-json-reader.js
import fs5 from "fs";
import path4 from "path";
import { fileURLToPath } from "url";
function read(jsonPath, { base, specifier }) {
  const existing = cache.get(jsonPath);
  if (existing) {
    return existing;
  }
  let string2;
  try {
    string2 = fs5.readFileSync(path4.toNamespacedPath(jsonPath), "utf8");
  } catch (error) {
    const exception2 = (
      /** @type {ErrnoException} */
      error
    );
    if (exception2.code !== "ENOENT") {
      throw exception2;
    }
  }
  const result = {
    exists: false,
    pjsonPath: jsonPath,
    main: void 0,
    name: void 0,
    type: "none",
    // Ignore unknown types for forwards compatibility
    exports: void 0,
    imports: void 0
  };
  if (string2 !== void 0) {
    let parsed;
    try {
      parsed = JSON.parse(string2);
    } catch (error_) {
      const cause = (
        /** @type {ErrnoException} */
        error_
      );
      const error = new ERR_INVALID_PACKAGE_CONFIG(
        jsonPath,
        (base ? `"${specifier}" from ` : "") + fileURLToPath(base || specifier),
        cause.message
      );
      error.cause = cause;
      throw error;
    }
    result.exists = true;
    if (hasOwnProperty.call(parsed, "name") && typeof parsed.name === "string") {
      result.name = parsed.name;
    }
    if (hasOwnProperty.call(parsed, "main") && typeof parsed.main === "string") {
      result.main = parsed.main;
    }
    if (hasOwnProperty.call(parsed, "exports")) {
      result.exports = parsed.exports;
    }
    if (hasOwnProperty.call(parsed, "imports")) {
      result.imports = parsed.imports;
    }
    if (hasOwnProperty.call(parsed, "type") && (parsed.type === "commonjs" || parsed.type === "module")) {
      result.type = parsed.type;
    }
  }
  cache.set(jsonPath, result);
  return result;
}
function getPackageScopeConfig(resolved) {
  let packageJSONUrl = new URL("package.json", resolved);
  while (true) {
    const packageJSONPath2 = packageJSONUrl.pathname;
    if (packageJSONPath2.endsWith("node_modules/package.json")) {
      break;
    }
    const packageConfig = read(fileURLToPath(packageJSONUrl), {
      specifier: resolved
    });
    if (packageConfig.exists) {
      return packageConfig;
    }
    const lastPackageJSONUrl = packageJSONUrl;
    packageJSONUrl = new URL("../package.json", packageJSONUrl);
    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
      break;
    }
  }
  const packageJSONPath = fileURLToPath(packageJSONUrl);
  return {
    pjsonPath: packageJSONPath,
    exists: false,
    type: "none"
  };
}
function getPackageType(url3) {
  return getPackageScopeConfig(url3).type;
}
var hasOwnProperty, ERR_INVALID_PACKAGE_CONFIG, cache;
var init_package_json_reader = __esm({
  "node_modules/import-meta-resolve/lib/package-json-reader.js"() {
    init_errors();
    hasOwnProperty = {}.hasOwnProperty;
    ({ ERR_INVALID_PACKAGE_CONFIG } = codes);
    cache = /* @__PURE__ */ new Map();
  }
});

// node_modules/import-meta-resolve/lib/get-format.js
import { fileURLToPath as fileURLToPath2 } from "url";
function mimeToFormat(mime) {
  if (mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime))
    return "module";
  if (mime === "application/json") return "json";
  return null;
}
function getDataProtocolModuleFormat(parsed) {
  const { 1: mime } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(
    parsed.pathname
  ) || [null, null, null];
  return mimeToFormat(mime);
}
function extname(url3) {
  const pathname = url3.pathname;
  let index = pathname.length;
  while (index--) {
    const code = pathname.codePointAt(index);
    if (code === 47) {
      return "";
    }
    if (code === 46) {
      return pathname.codePointAt(index - 1) === 47 ? "" : pathname.slice(index);
    }
  }
  return "";
}
function getFileProtocolModuleFormat(url3, _context, ignoreErrors) {
  const value = extname(url3);
  if (value === ".js") {
    const packageType = getPackageType(url3);
    if (packageType !== "none") {
      return packageType;
    }
    return "commonjs";
  }
  if (value === "") {
    const packageType = getPackageType(url3);
    if (packageType === "none" || packageType === "commonjs") {
      return "commonjs";
    }
    return "module";
  }
  const format2 = extensionFormatMap[value];
  if (format2) return format2;
  if (ignoreErrors) {
    return void 0;
  }
  const filepath = fileURLToPath2(url3);
  throw new ERR_UNKNOWN_FILE_EXTENSION(value, filepath);
}
function getHttpProtocolModuleFormat() {
}
function defaultGetFormatWithoutErrors(url3, context) {
  const protocol = url3.protocol;
  if (!hasOwnProperty2.call(protocolHandlers, protocol)) {
    return null;
  }
  return protocolHandlers[protocol](url3, context, true) || null;
}
var ERR_UNKNOWN_FILE_EXTENSION, hasOwnProperty2, extensionFormatMap, protocolHandlers;
var init_get_format = __esm({
  "node_modules/import-meta-resolve/lib/get-format.js"() {
    init_package_json_reader();
    init_errors();
    ({ ERR_UNKNOWN_FILE_EXTENSION } = codes);
    hasOwnProperty2 = {}.hasOwnProperty;
    extensionFormatMap = {
      // @ts-expect-error: hush.
      __proto__: null,
      ".cjs": "commonjs",
      ".js": "module",
      ".json": "json",
      ".mjs": "module"
    };
    protocolHandlers = {
      // @ts-expect-error: hush.
      __proto__: null,
      "data:": getDataProtocolModuleFormat,
      "file:": getFileProtocolModuleFormat,
      "http:": getHttpProtocolModuleFormat,
      "https:": getHttpProtocolModuleFormat,
      "node:"() {
        return "builtin";
      }
    };
  }
});

// node_modules/import-meta-resolve/lib/resolve.js
import assert2 from "assert";
import { statSync, realpathSync } from "fs";
import process9 from "process";
import { URL as URL2, fileURLToPath as fileURLToPath3, pathToFileURL } from "url";
import path5 from "path";
import { builtinModules } from "module";
function emitInvalidSegmentDeprecation(target, request, match2, packageJsonUrl, internal, base, isTarget) {
  if (process9.noDeprecation) {
    return;
  }
  const pjsonPath = fileURLToPath3(packageJsonUrl);
  const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
  process9.emitWarning(
    `Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target}" for module request "${request}" ${request === match2 ? "" : `matched to "${match2}" `}in the "${internal ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath3(base)}` : ""}.`,
    "DeprecationWarning",
    "DEP0166"
  );
}
function emitLegacyIndexDeprecation(url3, packageJsonUrl, base, main) {
  if (process9.noDeprecation) {
    return;
  }
  const format2 = defaultGetFormatWithoutErrors(url3, { parentURL: base.href });
  if (format2 !== "module") return;
  const urlPath = fileURLToPath3(url3.href);
  const packagePath = fileURLToPath3(new URL2(".", packageJsonUrl));
  const basePath = fileURLToPath3(base);
  if (!main) {
    process9.emitWarning(
      `No "main" or "exports" field defined in the package.json for ${packagePath} resolving the main entry point "${urlPath.slice(
        packagePath.length
      )}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`,
      "DeprecationWarning",
      "DEP0151"
    );
  } else if (path5.resolve(packagePath, main) !== urlPath) {
    process9.emitWarning(
      `Package ${packagePath} has a "main" field set to "${main}", excluding the full filename and extension to the resolved file at "${urlPath.slice(
        packagePath.length
      )}", imported from ${basePath}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`,
      "DeprecationWarning",
      "DEP0151"
    );
  }
}
function tryStatSync(path17) {
  try {
    return statSync(path17);
  } catch {
  }
}
function fileExists(url3) {
  const stats = statSync(url3, { throwIfNoEntry: false });
  const isFile = stats ? stats.isFile() : void 0;
  return isFile === null || isFile === void 0 ? false : isFile;
}
function legacyMainResolve(packageJsonUrl, packageConfig, base) {
  let guess;
  if (packageConfig.main !== void 0) {
    guess = new URL2(packageConfig.main, packageJsonUrl);
    if (fileExists(guess)) return guess;
    const tries2 = [
      `./${packageConfig.main}.js`,
      `./${packageConfig.main}.json`,
      `./${packageConfig.main}.node`,
      `./${packageConfig.main}/index.js`,
      `./${packageConfig.main}/index.json`,
      `./${packageConfig.main}/index.node`
    ];
    let i2 = -1;
    while (++i2 < tries2.length) {
      guess = new URL2(tries2[i2], packageJsonUrl);
      if (fileExists(guess)) break;
      guess = void 0;
    }
    if (guess) {
      emitLegacyIndexDeprecation(
        guess,
        packageJsonUrl,
        base,
        packageConfig.main
      );
      return guess;
    }
  }
  const tries = ["./index.js", "./index.json", "./index.node"];
  let i = -1;
  while (++i < tries.length) {
    guess = new URL2(tries[i], packageJsonUrl);
    if (fileExists(guess)) break;
    guess = void 0;
  }
  if (guess) {
    emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
    return guess;
  }
  throw new ERR_MODULE_NOT_FOUND(
    fileURLToPath3(new URL2(".", packageJsonUrl)),
    fileURLToPath3(base)
  );
}
function finalizeResolution(resolved, base, preserveSymlinks) {
  if (encodedSeparatorRegEx.exec(resolved.pathname) !== null) {
    throw new ERR_INVALID_MODULE_SPECIFIER(
      resolved.pathname,
      'must not include encoded "/" or "\\" characters',
      fileURLToPath3(base)
    );
  }
  let filePath;
  try {
    filePath = fileURLToPath3(resolved);
  } catch (error) {
    const cause = (
      /** @type {ErrnoException} */
      error
    );
    Object.defineProperty(cause, "input", { value: String(resolved) });
    Object.defineProperty(cause, "module", { value: String(base) });
    throw cause;
  }
  const stats = tryStatSync(
    filePath.endsWith("/") ? filePath.slice(-1) : filePath
  );
  if (stats && stats.isDirectory()) {
    const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, fileURLToPath3(base));
    error.url = String(resolved);
    throw error;
  }
  if (!stats || !stats.isFile()) {
    const error = new ERR_MODULE_NOT_FOUND(
      filePath || resolved.pathname,
      base && fileURLToPath3(base),
      true
    );
    error.url = String(resolved);
    throw error;
  }
  if (!preserveSymlinks) {
    const real = realpathSync(filePath);
    const { search, hash } = resolved;
    resolved = pathToFileURL(real + (filePath.endsWith(path5.sep) ? "/" : ""));
    resolved.search = search;
    resolved.hash = hash;
  }
  return resolved;
}
function importNotDefined(specifier, packageJsonUrl, base) {
  return new ERR_PACKAGE_IMPORT_NOT_DEFINED(
    specifier,
    packageJsonUrl && fileURLToPath3(new URL2(".", packageJsonUrl)),
    fileURLToPath3(base)
  );
}
function exportsNotFound(subpath, packageJsonUrl, base) {
  return new ERR_PACKAGE_PATH_NOT_EXPORTED(
    fileURLToPath3(new URL2(".", packageJsonUrl)),
    subpath,
    base && fileURLToPath3(base)
  );
}
function throwInvalidSubpath(request, match2, packageJsonUrl, internal, base) {
  const reason = `request is not a valid match in pattern "${match2}" for the "${internal ? "imports" : "exports"}" resolution of ${fileURLToPath3(packageJsonUrl)}`;
  throw new ERR_INVALID_MODULE_SPECIFIER(
    request,
    reason,
    base && fileURLToPath3(base)
  );
}
function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
  target = typeof target === "object" && target !== null ? JSON.stringify(target, null, "") : `${target}`;
  return new ERR_INVALID_PACKAGE_TARGET(
    fileURLToPath3(new URL2(".", packageJsonUrl)),
    subpath,
    target,
    internal,
    base && fileURLToPath3(base)
  );
}
function resolvePackageTargetString(target, subpath, match2, packageJsonUrl, base, pattern, internal, isPathMap, conditions) {
  if (subpath !== "" && !pattern && target[target.length - 1] !== "/")
    throw invalidPackageTarget(match2, target, packageJsonUrl, internal, base);
  if (!target.startsWith("./")) {
    if (internal && !target.startsWith("../") && !target.startsWith("/")) {
      let isURL = false;
      try {
        new URL2(target);
        isURL = true;
      } catch {
      }
      if (!isURL) {
        const exportTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target + subpath;
        return packageResolve(exportTarget, packageJsonUrl, conditions);
      }
    }
    throw invalidPackageTarget(match2, target, packageJsonUrl, internal, base);
  }
  if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {
    if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
      if (!isPathMap) {
        const request = pattern ? match2.replace("*", () => subpath) : match2 + subpath;
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match2,
          packageJsonUrl,
          internal,
          base,
          true
        );
      }
    } else {
      throw invalidPackageTarget(match2, target, packageJsonUrl, internal, base);
    }
  }
  const resolved = new URL2(target, packageJsonUrl);
  const resolvedPath = resolved.pathname;
  const packagePath = new URL2(".", packageJsonUrl).pathname;
  if (!resolvedPath.startsWith(packagePath))
    throw invalidPackageTarget(match2, target, packageJsonUrl, internal, base);
  if (subpath === "") return resolved;
  if (invalidSegmentRegEx.exec(subpath) !== null) {
    const request = pattern ? match2.replace("*", () => subpath) : match2 + subpath;
    if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
      if (!isPathMap) {
        const resolvedTarget = pattern ? RegExpPrototypeSymbolReplace.call(
          patternRegEx,
          target,
          () => subpath
        ) : target;
        emitInvalidSegmentDeprecation(
          resolvedTarget,
          request,
          match2,
          packageJsonUrl,
          internal,
          base,
          false
        );
      }
    } else {
      throwInvalidSubpath(request, match2, packageJsonUrl, internal, base);
    }
  }
  if (pattern) {
    return new URL2(
      RegExpPrototypeSymbolReplace.call(
        patternRegEx,
        resolved.href,
        () => subpath
      )
    );
  }
  return new URL2(subpath, resolved);
}
function isArrayIndex(key2) {
  const keyNumber = Number(key2);
  if (`${keyNumber}` !== key2) return false;
  return keyNumber >= 0 && keyNumber < 4294967295;
}
function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern, internal, isPathMap, conditions) {
  if (typeof target === "string") {
    return resolvePackageTargetString(
      target,
      subpath,
      packageSubpath,
      packageJsonUrl,
      base,
      pattern,
      internal,
      isPathMap,
      conditions
    );
  }
  if (Array.isArray(target)) {
    const targetList = target;
    if (targetList.length === 0) return null;
    let lastException;
    let i = -1;
    while (++i < targetList.length) {
      const targetItem = targetList[i];
      let resolveResult;
      try {
        resolveResult = resolvePackageTarget(
          packageJsonUrl,
          targetItem,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          isPathMap,
          conditions
        );
      } catch (error) {
        const exception2 = (
          /** @type {ErrnoException} */
          error
        );
        lastException = exception2;
        if (exception2.code === "ERR_INVALID_PACKAGE_TARGET") continue;
        throw error;
      }
      if (resolveResult === void 0) continue;
      if (resolveResult === null) {
        lastException = null;
        continue;
      }
      return resolveResult;
    }
    if (lastException === void 0 || lastException === null) {
      return null;
    }
    throw lastException;
  }
  if (typeof target === "object" && target !== null) {
    const keys = Object.getOwnPropertyNames(target);
    let i = -1;
    while (++i < keys.length) {
      const key2 = keys[i];
      if (isArrayIndex(key2)) {
        throw new ERR_INVALID_PACKAGE_CONFIG2(
          fileURLToPath3(packageJsonUrl),
          base,
          '"exports" cannot contain numeric property keys.'
        );
      }
    }
    i = -1;
    while (++i < keys.length) {
      const key2 = keys[i];
      if (key2 === "default" || conditions && conditions.has(key2)) {
        const conditionalTarget = (
          /** @type {unknown} */
          target[key2]
        );
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          conditionalTarget,
          subpath,
          packageSubpath,
          base,
          pattern,
          internal,
          isPathMap,
          conditions
        );
        if (resolveResult === void 0) continue;
        return resolveResult;
      }
    }
    return null;
  }
  if (target === null) {
    return null;
  }
  throw invalidPackageTarget(
    packageSubpath,
    target,
    packageJsonUrl,
    internal,
    base
  );
}
function isConditionalExportsMainSugar(exports, packageJsonUrl, base) {
  if (typeof exports === "string" || Array.isArray(exports)) return true;
  if (typeof exports !== "object" || exports === null) return false;
  const keys = Object.getOwnPropertyNames(exports);
  let isConditionalSugar = false;
  let i = 0;
  let keyIndex = -1;
  while (++keyIndex < keys.length) {
    const key2 = keys[keyIndex];
    const currentIsConditionalSugar = key2 === "" || key2[0] !== ".";
    if (i++ === 0) {
      isConditionalSugar = currentIsConditionalSugar;
    } else if (isConditionalSugar !== currentIsConditionalSugar) {
      throw new ERR_INVALID_PACKAGE_CONFIG2(
        fileURLToPath3(packageJsonUrl),
        base,
        `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`
      );
    }
  }
  return isConditionalSugar;
}
function emitTrailingSlashPatternDeprecation(match2, pjsonUrl, base) {
  if (process9.noDeprecation) {
    return;
  }
  const pjsonPath = fileURLToPath3(pjsonUrl);
  if (emittedPackageWarnings.has(pjsonPath + "|" + match2)) return;
  emittedPackageWarnings.add(pjsonPath + "|" + match2);
  process9.emitWarning(
    `Use of deprecated trailing slash pattern mapping "${match2}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath3(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`,
    "DeprecationWarning",
    "DEP0155"
  );
}
function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
  let exports = packageConfig.exports;
  if (isConditionalExportsMainSugar(exports, packageJsonUrl, base)) {
    exports = { ".": exports };
  }
  if (own2.call(exports, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
    const target = exports[packageSubpath];
    const resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      "",
      packageSubpath,
      base,
      false,
      false,
      false,
      conditions
    );
    if (resolveResult === null || resolveResult === void 0) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  let bestMatch = "";
  let bestMatchSubpath = "";
  const keys = Object.getOwnPropertyNames(exports);
  let i = -1;
  while (++i < keys.length) {
    const key2 = keys[i];
    const patternIndex = key2.indexOf("*");
    if (patternIndex !== -1 && packageSubpath.startsWith(key2.slice(0, patternIndex))) {
      if (packageSubpath.endsWith("/")) {
        emitTrailingSlashPatternDeprecation(
          packageSubpath,
          packageJsonUrl,
          base
        );
      }
      const patternTrailer = key2.slice(patternIndex + 1);
      if (packageSubpath.length >= key2.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key2) === 1 && key2.lastIndexOf("*") === patternIndex) {
        bestMatch = key2;
        bestMatchSubpath = packageSubpath.slice(
          patternIndex,
          packageSubpath.length - patternTrailer.length
        );
      }
    }
  }
  if (bestMatch) {
    const target = (
      /** @type {unknown} */
      exports[bestMatch]
    );
    const resolveResult = resolvePackageTarget(
      packageJsonUrl,
      target,
      bestMatchSubpath,
      bestMatch,
      base,
      true,
      false,
      packageSubpath.endsWith("/"),
      conditions
    );
    if (resolveResult === null || resolveResult === void 0) {
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    return resolveResult;
  }
  throw exportsNotFound(packageSubpath, packageJsonUrl, base);
}
function patternKeyCompare(a, b) {
  const aPatternIndex = a.indexOf("*");
  const bPatternIndex = b.indexOf("*");
  const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
  const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
  if (baseLengthA > baseLengthB) return -1;
  if (baseLengthB > baseLengthA) return 1;
  if (aPatternIndex === -1) return 1;
  if (bPatternIndex === -1) return -1;
  if (a.length > b.length) return -1;
  if (b.length > a.length) return 1;
  return 0;
}
function packageImportsResolve(name, base, conditions) {
  if (name === "#" || name.startsWith("#/") || name.endsWith("/")) {
    const reason = "is not a valid internal imports specifier name";
    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, fileURLToPath3(base));
  }
  let packageJsonUrl;
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    packageJsonUrl = pathToFileURL(packageConfig.pjsonPath);
    const imports = packageConfig.imports;
    if (imports) {
      if (own2.call(imports, name) && !name.includes("*")) {
        const resolveResult = resolvePackageTarget(
          packageJsonUrl,
          imports[name],
          "",
          name,
          base,
          false,
          true,
          false,
          conditions
        );
        if (resolveResult !== null && resolveResult !== void 0) {
          return resolveResult;
        }
      } else {
        let bestMatch = "";
        let bestMatchSubpath = "";
        const keys = Object.getOwnPropertyNames(imports);
        let i = -1;
        while (++i < keys.length) {
          const key2 = keys[i];
          const patternIndex = key2.indexOf("*");
          if (patternIndex !== -1 && name.startsWith(key2.slice(0, -1))) {
            const patternTrailer = key2.slice(patternIndex + 1);
            if (name.length >= key2.length && name.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key2) === 1 && key2.lastIndexOf("*") === patternIndex) {
              bestMatch = key2;
              bestMatchSubpath = name.slice(
                patternIndex,
                name.length - patternTrailer.length
              );
            }
          }
        }
        if (bestMatch) {
          const target = imports[bestMatch];
          const resolveResult = resolvePackageTarget(
            packageJsonUrl,
            target,
            bestMatchSubpath,
            bestMatch,
            base,
            true,
            true,
            false,
            conditions
          );
          if (resolveResult !== null && resolveResult !== void 0) {
            return resolveResult;
          }
        }
      }
    }
  }
  throw importNotDefined(name, packageJsonUrl, base);
}
function parsePackageName(specifier, base) {
  let separatorIndex = specifier.indexOf("/");
  let validPackageName = true;
  let isScoped = false;
  if (specifier[0] === "@") {
    isScoped = true;
    if (separatorIndex === -1 || specifier.length === 0) {
      validPackageName = false;
    } else {
      separatorIndex = specifier.indexOf("/", separatorIndex + 1);
    }
  }
  const packageName = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
  if (invalidPackageNameRegEx.exec(packageName) !== null) {
    validPackageName = false;
  }
  if (!validPackageName) {
    throw new ERR_INVALID_MODULE_SPECIFIER(
      specifier,
      "is not a valid package name",
      fileURLToPath3(base)
    );
  }
  const packageSubpath = "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex));
  return { packageName, packageSubpath, isScoped };
}
function packageResolve(specifier, base, conditions) {
  if (builtinModules.includes(specifier)) {
    return new URL2("node:" + specifier);
  }
  const { packageName, packageSubpath, isScoped } = parsePackageName(
    specifier,
    base
  );
  const packageConfig = getPackageScopeConfig(base);
  if (packageConfig.exists) {
    const packageJsonUrl2 = pathToFileURL(packageConfig.pjsonPath);
    if (packageConfig.name === packageName && packageConfig.exports !== void 0 && packageConfig.exports !== null) {
      return packageExportsResolve(
        packageJsonUrl2,
        packageSubpath,
        packageConfig,
        base,
        conditions
      );
    }
  }
  let packageJsonUrl = new URL2(
    "./node_modules/" + packageName + "/package.json",
    base
  );
  let packageJsonPath = fileURLToPath3(packageJsonUrl);
  let lastPath;
  do {
    const stat = tryStatSync(packageJsonPath.slice(0, -13));
    if (!stat || !stat.isDirectory()) {
      lastPath = packageJsonPath;
      packageJsonUrl = new URL2(
        (isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName + "/package.json",
        packageJsonUrl
      );
      packageJsonPath = fileURLToPath3(packageJsonUrl);
      continue;
    }
    const packageConfig2 = read(packageJsonPath, { base, specifier });
    if (packageConfig2.exports !== void 0 && packageConfig2.exports !== null) {
      return packageExportsResolve(
        packageJsonUrl,
        packageSubpath,
        packageConfig2,
        base,
        conditions
      );
    }
    if (packageSubpath === ".") {
      return legacyMainResolve(packageJsonUrl, packageConfig2, base);
    }
    return new URL2(packageSubpath, packageJsonUrl);
  } while (packageJsonPath.length !== lastPath.length);
  throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath3(base), false);
}
function isRelativeSpecifier(specifier) {
  if (specifier[0] === ".") {
    if (specifier.length === 1 || specifier[1] === "/") return true;
    if (specifier[1] === "." && (specifier.length === 2 || specifier[2] === "/")) {
      return true;
    }
  }
  return false;
}
function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
  if (specifier === "") return false;
  if (specifier[0] === "/") return true;
  return isRelativeSpecifier(specifier);
}
function moduleResolve(specifier, base, conditions, preserveSymlinks) {
  const protocol = base.protocol;
  const isData = protocol === "data:";
  const isRemote = isData || protocol === "http:" || protocol === "https:";
  let resolved;
  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
    try {
      resolved = new URL2(specifier, base);
    } catch (error_) {
      const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
      error.cause = error_;
      throw error;
    }
  } else if (protocol === "file:" && specifier[0] === "#") {
    resolved = packageImportsResolve(specifier, base, conditions);
  } else {
    try {
      resolved = new URL2(specifier);
    } catch (error_) {
      if (isRemote && !builtinModules.includes(specifier)) {
        const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
        error.cause = error_;
        throw error;
      }
      resolved = packageResolve(specifier, base, conditions);
    }
  }
  assert2(resolved !== void 0, "expected to be defined");
  if (resolved.protocol !== "file:") {
    return resolved;
  }
  return finalizeResolution(resolved, base, preserveSymlinks);
}
var RegExpPrototypeSymbolReplace, ERR_NETWORK_IMPORT_DISALLOWED, ERR_INVALID_MODULE_SPECIFIER, ERR_INVALID_PACKAGE_CONFIG2, ERR_INVALID_PACKAGE_TARGET, ERR_MODULE_NOT_FOUND, ERR_PACKAGE_IMPORT_NOT_DEFINED, ERR_PACKAGE_PATH_NOT_EXPORTED, ERR_UNSUPPORTED_DIR_IMPORT, ERR_UNSUPPORTED_RESOLVE_REQUEST, own2, invalidSegmentRegEx, deprecatedInvalidSegmentRegEx, invalidPackageNameRegEx, patternRegEx, encodedSeparatorRegEx, emittedPackageWarnings, doubleSlashRegEx;
var init_resolve = __esm({
  "node_modules/import-meta-resolve/lib/resolve.js"() {
    init_get_format();
    init_errors();
    init_package_json_reader();
    RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
    ({
      ERR_NETWORK_IMPORT_DISALLOWED,
      ERR_INVALID_MODULE_SPECIFIER,
      ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG2,
      ERR_INVALID_PACKAGE_TARGET,
      ERR_MODULE_NOT_FOUND,
      ERR_PACKAGE_IMPORT_NOT_DEFINED,
      ERR_PACKAGE_PATH_NOT_EXPORTED,
      ERR_UNSUPPORTED_DIR_IMPORT,
      ERR_UNSUPPORTED_RESOLVE_REQUEST
    } = codes);
    own2 = {}.hasOwnProperty;
    invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
    deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
    invalidPackageNameRegEx = /^\.|%|\\/;
    patternRegEx = /\*/g;
    encodedSeparatorRegEx = /%2f|%5c/i;
    emittedPackageWarnings = /* @__PURE__ */ new Set();
    doubleSlashRegEx = /[/\\]{2}/;
  }
});

// node_modules/import-meta-resolve/index.js
var init_import_meta_resolve = __esm({
  "node_modules/import-meta-resolve/index.js"() {
    init_resolve();
  }
});

// node_modules/lomemo/dist/index.js
var memoize, dist_default13;
var init_dist14 = __esm({
  "node_modules/lomemo/dist/index.js"() {
    memoize = (fn, resolver) => {
      const memoized = function(...args) {
        const key2 = resolver ? resolver.apply(this, args) : args[0];
        const cache3 = memoized.cache;
        const cached = cache3.get(key2);
        if (cached !== void 0 || cache3.has(key2))
          return cached;
        const result = fn.apply(this, args);
        memoized.cache = cache3.set(key2, result) || cache3;
        return result;
      };
      memoized.cache = new (memoize.Cache || Map)();
      return memoized;
    };
    memoize.Cache = Map;
    dist_default13 = memoize;
  }
});

// node_modules/promise-resolve-timeout/dist/index.js
function resolveTimeout(timeout, value) {
  return new Promise((resolve4) => {
    if (timeout === Infinity)
      return;
    setTimeout(() => {
      if (typeof value === "function") {
        resolve4(value());
      } else {
        resolve4(value);
      }
    }, timeout);
  });
}
var dist_default14;
var init_dist15 = __esm({
  "node_modules/promise-resolve-timeout/dist/index.js"() {
    dist_default14 = resolveTimeout;
  }
});

// node_modules/promise-make-naked/dist/utils.js
var noop;
var init_utils7 = __esm({
  "node_modules/promise-make-naked/dist/utils.js"() {
    noop = () => {
    };
  }
});

// node_modules/promise-make-naked/dist/index.js
var makeNakedPromise, dist_default15;
var init_dist16 = __esm({
  "node_modules/promise-make-naked/dist/index.js"() {
    init_utils7();
    makeNakedPromise = () => {
      let resolve4 = noop;
      let reject = noop;
      let resolved = false;
      let rejected = false;
      const promise = new Promise((res, rej) => {
        resolve4 = (value) => {
          resolved = true;
          return res(value);
        };
        reject = (value) => {
          rejected = true;
          return rej(value);
        };
      });
      const isPending = () => !resolved && !rejected;
      const isResolved = () => resolved;
      const isRejected = () => rejected;
      return { promise, resolve: resolve4, reject, isPending, isResolved, isRejected };
    };
    dist_default15 = makeNakedPromise;
  }
});

// node_modules/promise-make-counter/dist/index.js
var makeCounterPromise, dist_default16;
var init_dist17 = __esm({
  "node_modules/promise-make-counter/dist/index.js"() {
    init_dist16();
    makeCounterPromise = () => {
      const { promise, resolve: resolve4, isPending } = dist_default15();
      let counter = 0;
      const increment = () => {
        counter += 1;
      };
      const decrement = () => {
        counter -= 1;
        if (counter)
          return;
        resolve4();
      };
      const init = () => {
        increment();
        queueMicrotask(decrement);
      };
      init();
      return { promise, isPending, increment, decrement };
    };
    dist_default16 = makeCounterPromise;
  }
});

// node_modules/tiny-readdir/dist/constants.js
var NOOP_PROMISE_LIKE;
var init_constants4 = __esm({
  "node_modules/tiny-readdir/dist/constants.js"() {
    NOOP_PROMISE_LIKE = {
      then: (fn) => {
        fn();
      }
    };
  }
});

// node_modules/tiny-readdir/dist/utils.js
var castArray3, isFunction;
var init_utils8 = __esm({
  "node_modules/tiny-readdir/dist/utils.js"() {
    castArray3 = (value) => {
      return Array.isArray(value) ? value : [value];
    };
    isFunction = (value) => {
      return typeof value === "function";
    };
  }
});

// node_modules/tiny-readdir/dist/index.js
import fs6 from "fs";
import path6 from "path";
var readdir, dist_default17;
var init_dist18 = __esm({
  "node_modules/tiny-readdir/dist/index.js"() {
    init_dist17();
    init_constants4();
    init_utils8();
    readdir = (rootPath, options) => {
      const followSymlinks = (options == null ? void 0 : options.followSymlinks) ?? false;
      const maxDepth = (options == null ? void 0 : options.depth) ?? Infinity;
      const maxPaths = (options == null ? void 0 : options.limit) ?? Infinity;
      const ignore = (options == null ? void 0 : options.ignore) ?? [];
      const ignores = castArray3(ignore).map((ignore2) => isFunction(ignore2) ? ignore2 : (targetPath) => ignore2.test(targetPath));
      const isIgnored = (targetPath) => ignores.some((ignore2) => ignore2(targetPath));
      const signal = (options == null ? void 0 : options.signal) ?? { aborted: false };
      const onDirents = (options == null ? void 0 : options.onDirents) || (() => {
      });
      const directories = [];
      const directoriesNames = /* @__PURE__ */ new Set();
      const directoriesNamesToPaths = {};
      const files = [];
      const filesNames = /* @__PURE__ */ new Set();
      const filesNamesToPaths = {};
      const symlinks = [];
      const symlinksNames = /* @__PURE__ */ new Set();
      const symlinksNamesToPaths = {};
      const map2 = {};
      const visited = /* @__PURE__ */ new Set();
      const resultEmpty = { directories: [], directoriesNames: /* @__PURE__ */ new Set(), directoriesNamesToPaths: {}, files: [], filesNames: /* @__PURE__ */ new Set(), filesNamesToPaths: {}, symlinks: [], symlinksNames: /* @__PURE__ */ new Set(), symlinksNamesToPaths: {}, map: {} };
      const result = { directories, directoriesNames, directoriesNamesToPaths, files, filesNames, filesNamesToPaths, symlinks, symlinksNames, symlinksNamesToPaths, map: map2 };
      const { promise, increment, decrement } = dist_default16();
      let foundPaths = 0;
      const handleDirectory = (dirmap, subPath, name, depth) => {
        if (visited.has(subPath))
          return;
        if (foundPaths >= maxPaths)
          return;
        foundPaths += 1;
        dirmap.directories.push(subPath);
        dirmap.directoriesNames.add(name);
        directories.push(subPath);
        directoriesNames.add(name);
        directoriesNamesToPaths.propertyIsEnumerable(name) || (directoriesNamesToPaths[name] = []);
        directoriesNamesToPaths[name].push(subPath);
        visited.add(subPath);
        if (depth >= maxDepth)
          return;
        if (foundPaths >= maxPaths)
          return;
        populateResultFromPath(subPath, depth + 1);
      };
      const handleFile = (dirmap, subPath, name) => {
        if (visited.has(subPath))
          return;
        if (foundPaths >= maxPaths)
          return;
        foundPaths += 1;
        dirmap.files.push(subPath);
        dirmap.filesNames.add(name);
        files.push(subPath);
        filesNames.add(name);
        filesNamesToPaths.propertyIsEnumerable(name) || (filesNamesToPaths[name] = []);
        filesNamesToPaths[name].push(subPath);
        visited.add(subPath);
      };
      const handleSymlink = (dirmap, subPath, name, depth) => {
        if (visited.has(subPath))
          return;
        if (foundPaths >= maxPaths)
          return;
        foundPaths += 1;
        dirmap.symlinks.push(subPath);
        dirmap.symlinksNames.add(name);
        symlinks.push(subPath);
        symlinksNames.add(name);
        symlinksNamesToPaths.propertyIsEnumerable(name) || (symlinksNamesToPaths[name] = []);
        symlinksNamesToPaths[name].push(subPath);
        visited.add(subPath);
        if (!followSymlinks)
          return;
        if (depth >= maxDepth)
          return;
        if (foundPaths >= maxPaths)
          return;
        populateResultFromSymlink(subPath, depth + 1);
      };
      const handleStat = (dirmap, rootPath2, name, stat, depth) => {
        if (signal.aborted)
          return;
        if (isIgnored(rootPath2))
          return;
        if (stat.isDirectory()) {
          handleDirectory(dirmap, rootPath2, name, depth);
        } else if (stat.isFile()) {
          handleFile(dirmap, rootPath2, name);
        } else if (stat.isSymbolicLink()) {
          handleSymlink(dirmap, rootPath2, name, depth);
        }
      };
      const handleDirent = (dirmap, rootPath2, dirent, depth) => {
        if (signal.aborted)
          return;
        const separator = rootPath2 === path6.sep ? "" : path6.sep;
        const name = dirent.name;
        const subPath = `${rootPath2}${separator}${name}`;
        if (isIgnored(subPath))
          return;
        if (dirent.isDirectory()) {
          handleDirectory(dirmap, subPath, name, depth);
        } else if (dirent.isFile()) {
          handleFile(dirmap, subPath, name);
        } else if (dirent.isSymbolicLink()) {
          handleSymlink(dirmap, subPath, name, depth);
        }
      };
      const handleDirents = (dirmap, rootPath2, dirents, depth) => {
        for (let i = 0, l = dirents.length; i < l; i++) {
          handleDirent(dirmap, rootPath2, dirents[i], depth);
        }
      };
      const populateResultFromPath = (rootPath2, depth) => {
        if (signal.aborted)
          return;
        if (depth > maxDepth)
          return;
        if (foundPaths >= maxPaths)
          return;
        increment();
        fs6.readdir(rootPath2, { withFileTypes: true }, (error, dirents) => {
          if (error)
            return decrement();
          if (signal.aborted)
            return decrement();
          if (!dirents.length)
            return decrement();
          const promise2 = onDirents(dirents) || NOOP_PROMISE_LIKE;
          promise2.then(() => {
            const dirmap = map2[rootPath2] = { directories: [], directoriesNames: /* @__PURE__ */ new Set(), directoriesNamesToPaths: {}, files: [], filesNames: /* @__PURE__ */ new Set(), filesNamesToPaths: {}, symlinks: [], symlinksNames: /* @__PURE__ */ new Set(), symlinksNamesToPaths: {} };
            handleDirents(dirmap, rootPath2, dirents, depth);
            decrement();
          });
        });
      };
      const populateResultFromSymlink = (rootPath2, depth) => {
        increment();
        fs6.realpath(rootPath2, (error, realPath) => {
          if (error)
            return decrement();
          if (signal.aborted)
            return decrement();
          fs6.stat(realPath, (error2, stat) => {
            if (error2)
              return decrement();
            if (signal.aborted)
              return decrement();
            const name = path6.basename(realPath);
            const dirmap = map2[rootPath2] = { directories: [], directoriesNames: /* @__PURE__ */ new Set(), directoriesNamesToPaths: {}, files: [], filesNames: /* @__PURE__ */ new Set(), filesNamesToPaths: {}, symlinks: [], symlinksNames: /* @__PURE__ */ new Set(), symlinksNamesToPaths: {} };
            handleStat(dirmap, realPath, name, stat, depth);
            decrement();
          });
        });
      };
      const populateResultFromRoot = async (rootPath2, depth = 1) => {
        rootPath2 = path6.normalize(rootPath2);
        visited.add(rootPath2);
        populateResultFromPath(rootPath2, depth);
        await promise;
        if (signal.aborted)
          return resultEmpty;
        return result;
      };
      return populateResultFromRoot(rootPath);
    };
    dist_default17 = readdir;
  }
});

// node_modules/grammex/dist/utils.js
var isArray2, isFunction2, isFunctionNullary, isFunctionStrictlyNullaryOrUnary, isNumber, isObject, isRegExp, isRegExpCapturing, isRegExpStatic, isString, isUndefined3, memoize2;
var init_utils9 = __esm({
  "node_modules/grammex/dist/utils.js"() {
    isArray2 = (value) => {
      return Array.isArray(value);
    };
    isFunction2 = (value) => {
      return typeof value === "function";
    };
    isFunctionNullary = (value) => {
      return value.length === 0;
    };
    isFunctionStrictlyNullaryOrUnary = (() => {
      const { toString: toString2 } = Function.prototype;
      const re = /(?:^\(\s*(?:[^,.()]|\.(?!\.\.))*\s*\)\s*=>|^\s*[a-zA-Z$_][a-zA-Z0-9$_]*\s*=>)/;
      return (value) => {
        return (value.length === 0 || value.length === 1) && re.test(toString2.call(value));
      };
    })();
    isNumber = (value) => {
      return typeof value === "number";
    };
    isObject = (value) => {
      return typeof value === "object" && value !== null;
    };
    isRegExp = (value) => {
      return value instanceof RegExp;
    };
    isRegExpCapturing = /* @__PURE__ */ (() => {
      const sourceRe = /\\\(|\((?!\?(?::|=|!|<=|<!))/;
      return (re) => {
        return sourceRe.test(re.source);
      };
    })();
    isRegExpStatic = /* @__PURE__ */ (() => {
      const sourceRe = /^[a-zA-Z0-9_-]+$/;
      return (re) => {
        return sourceRe.test(re.source) && !re.flags.includes("i");
      };
    })();
    isString = (value) => {
      return typeof value === "string";
    };
    isUndefined3 = (value) => {
      return value === void 0;
    };
    memoize2 = (fn) => {
      const cache3 = /* @__PURE__ */ new Map();
      return (arg) => {
        const cached = cache3.get(arg);
        if (cached !== void 0)
          return cached;
        const value = fn(arg);
        cache3.set(arg, value);
        return value;
      };
    };
  }
});

// node_modules/grammex/dist/index.js
var parse, match, chars, regex, regexCapturing, regexNonCapturing, string, repeat, optional, star, and, or, backtrackable, handleable, memoizable, lazy, resolve;
var init_dist19 = __esm({
  "node_modules/grammex/dist/index.js"() {
    init_utils9();
    parse = (input, rule, options = {}) => {
      const state = { cache: {}, input, index: 0, indexBacktrackMax: 0, options, output: [] };
      const matched = resolve(rule)(state);
      const indexMax = Math.max(state.index, state.indexBacktrackMax);
      if (matched && state.index === input.length) {
        return state.output;
      } else {
        throw new Error(`Failed to parse at index ${indexMax}`);
      }
    };
    match = (target, handler) => {
      if (isArray2(target)) {
        return chars(target, handler);
      } else if (isString(target)) {
        return string(target, handler);
      } else {
        return regex(target, handler);
      }
    };
    chars = (target, handler) => {
      const charCodes = {};
      for (const char of target) {
        if (char.length !== 1)
          throw new Error(`Invalid character: "${char}"`);
        const charCode = char.charCodeAt(0);
        charCodes[charCode] = true;
      }
      return (state) => {
        const input = state.input;
        let indexStart = state.index;
        let indexEnd = indexStart;
        while (indexEnd < input.length) {
          const charCode = input.charCodeAt(indexEnd);
          if (!(charCode in charCodes))
            break;
          indexEnd += 1;
        }
        if (indexEnd > indexStart) {
          if (!isUndefined3(handler) && !state.options.silent) {
            const target2 = input.slice(indexStart, indexEnd);
            const output = isFunction2(handler) ? handler(target2, input, `${indexStart}`) : handler;
            if (!isUndefined3(output)) {
              state.output.push(output);
            }
          }
          state.index = indexEnd;
        }
        return true;
      };
    };
    regex = (target, handler) => {
      if (isRegExpStatic(target)) {
        return string(target.source, handler);
      } else {
        const source2 = target.source;
        const flags = target.flags.replace(/y|$/, "y");
        const re = new RegExp(source2, flags);
        if (isRegExpCapturing(target) && isFunction2(handler) && !isFunctionStrictlyNullaryOrUnary(handler)) {
          return regexCapturing(re, handler);
        } else {
          return regexNonCapturing(re, handler);
        }
      }
    };
    regexCapturing = (re, handler) => {
      return (state) => {
        const indexStart = state.index;
        const input = state.input;
        re.lastIndex = indexStart;
        const match2 = re.exec(input);
        if (match2) {
          const indexEnd = re.lastIndex;
          if (!state.options.silent) {
            const output = handler(...match2, input, `${indexStart}`);
            if (!isUndefined3(output)) {
              state.output.push(output);
            }
          }
          state.index = indexEnd;
          return true;
        } else {
          return false;
        }
      };
    };
    regexNonCapturing = (re, handler) => {
      return (state) => {
        const indexStart = state.index;
        const input = state.input;
        re.lastIndex = indexStart;
        const matched = re.test(input);
        if (matched) {
          const indexEnd = re.lastIndex;
          if (!isUndefined3(handler) && !state.options.silent) {
            const output = isFunction2(handler) ? handler(input.slice(indexStart, indexEnd), input, `${indexStart}`) : handler;
            if (!isUndefined3(output)) {
              state.output.push(output);
            }
          }
          state.index = indexEnd;
          return true;
        } else {
          return false;
        }
      };
    };
    string = (target, handler) => {
      return (state) => {
        const indexStart = state.index;
        const input = state.input;
        const matched = input.startsWith(target, indexStart);
        if (matched) {
          if (!isUndefined3(handler) && !state.options.silent) {
            const output = isFunction2(handler) ? handler(target, input, `${indexStart}`) : handler;
            if (!isUndefined3(output)) {
              state.output.push(output);
            }
          }
          state.index += target.length;
          return true;
        } else {
          return false;
        }
      };
    };
    repeat = (rule, min, max, handler) => {
      const erule = resolve(rule);
      const isBacktrackable = min > 1;
      return memoizable(handleable(backtrackable((state) => {
        let repetitions = 0;
        while (repetitions < max) {
          const index = state.index;
          const matched = erule(state);
          if (!matched)
            break;
          repetitions += 1;
          if (state.index === index)
            break;
        }
        return repetitions >= min;
      }, isBacktrackable), handler));
    };
    optional = (rule, handler) => {
      return repeat(rule, 0, 1, handler);
    };
    star = (rule, handler) => {
      return repeat(rule, 0, Infinity, handler);
    };
    and = (rules, handler) => {
      const erules = rules.map(resolve);
      return memoizable(handleable(backtrackable((state) => {
        for (let i = 0, l = erules.length; i < l; i++) {
          if (!erules[i](state))
            return false;
        }
        return true;
      }), handler));
    };
    or = (rules, handler) => {
      const erules = rules.map(resolve);
      return memoizable(handleable((state) => {
        for (let i = 0, l = erules.length; i < l; i++) {
          if (erules[i](state))
            return true;
        }
        return false;
      }, handler));
    };
    backtrackable = (rule, enabled = true, force = false) => {
      const erule = resolve(rule);
      if (!enabled)
        return erule;
      return (state) => {
        const index = state.index;
        const length = state.output.length;
        const matched = erule(state);
        if (!matched && !force) {
          state.indexBacktrackMax = Math.max(state.indexBacktrackMax, state.index);
        }
        if (!matched || force) {
          state.index = index;
          if (state.output.length !== length) {
            state.output.length = length;
          }
        }
        return matched;
      };
    };
    handleable = (rule, handler) => {
      const erule = resolve(rule);
      if (!handler)
        return erule;
      return (state) => {
        if (state.options.silent)
          return erule(state);
        const length = state.output.length;
        const matched = erule(state);
        if (matched) {
          const outputs = state.output.splice(length, Infinity);
          const output = handler(outputs);
          if (!isUndefined3(output)) {
            state.output.push(output);
          }
          return true;
        } else {
          return false;
        }
      };
    };
    memoizable = /* @__PURE__ */ (() => {
      let RULE_ID = 0;
      return (rule) => {
        const erule = resolve(rule);
        const ruleId = RULE_ID += 1;
        return (state) => {
          var _a5;
          var _a4;
          if (state.options.memoization === false)
            return erule(state);
          const indexStart = state.index;
          const cache3 = (_a4 = state.cache)[ruleId] || (_a4[ruleId] = { indexMax: -1, queue: [] });
          const cacheQueue = cache3.queue;
          const isPotentiallyCached = indexStart <= cache3.indexMax;
          if (isPotentiallyCached) {
            const cacheStore = cache3.store || (cache3.store = /* @__PURE__ */ new Map());
            if (cacheQueue.length) {
              for (let i = 0, l = cacheQueue.length; i < l; i += 2) {
                const key2 = cacheQueue[i * 2];
                const value = cacheQueue[i * 2 + 1];
                cacheStore.set(key2, value);
              }
              cacheQueue.length = 0;
            }
            const cached = cacheStore.get(indexStart);
            if (cached === false) {
              return false;
            } else if (isNumber(cached)) {
              state.index = cached;
              return true;
            } else if (cached) {
              state.index = cached.index;
              if ((_a5 = cached.output) == null ? void 0 : _a5.length) {
                state.output.push(...cached.output);
              }
              return true;
            }
          }
          const lengthStart = state.output.length;
          const matched = erule(state);
          cache3.indexMax = Math.max(cache3.indexMax, indexStart);
          if (matched) {
            const indexEnd = state.index;
            const lengthEnd = state.output.length;
            if (lengthEnd > lengthStart) {
              const output = state.output.slice(lengthStart, lengthEnd);
              cacheQueue.push(indexStart, { index: indexEnd, output });
            } else {
              cacheQueue.push(indexStart, indexEnd);
            }
            return true;
          } else {
            cacheQueue.push(indexStart, false);
            return false;
          }
        };
      };
    })();
    lazy = (getter) => {
      let erule;
      return (state) => {
        erule || (erule = resolve(getter()));
        return erule(state);
      };
    };
    resolve = memoize2((rule) => {
      if (isFunction2(rule)) {
        if (isFunctionNullary(rule)) {
          return lazy(rule);
        } else {
          return rule;
        }
      }
      if (isString(rule) || isRegExp(rule)) {
        return match(rule);
      }
      if (isArray2(rule)) {
        return and(rule);
      }
      if (isObject(rule)) {
        return or(Object.values(rule));
      }
      throw new Error("Invalid rule");
    });
  }
});

// node_modules/zeptomatch/dist/utils.js
var identity2, makeParser, memoize3;
var init_utils10 = __esm({
  "node_modules/zeptomatch/dist/utils.js"() {
    init_dist19();
    identity2 = (value) => {
      return value;
    };
    makeParser = (grammar) => {
      return (input) => {
        return parse(input, grammar, { memoization: false }).join("");
      };
    };
    memoize3 = (fn) => {
      const cache3 = {};
      return (arg) => {
        return cache3[arg] ?? (cache3[arg] = fn(arg));
      };
    };
  }
});

// node_modules/zeptomatch/dist/range.js
var ALPHABET, int2alpha, alpha2int, makeRangeInt, makeRangePaddedInt, makeRangeAlpha;
var init_range = __esm({
  "node_modules/zeptomatch/dist/range.js"() {
    ALPHABET = "abcdefghijklmnopqrstuvwxyz";
    int2alpha = (int2) => {
      let alpha = "";
      while (int2 > 0) {
        const reminder = (int2 - 1) % 26;
        alpha = ALPHABET[reminder] + alpha;
        int2 = Math.floor((int2 - 1) / 26);
      }
      return alpha;
    };
    alpha2int = (str2) => {
      let int2 = 0;
      for (let i = 0, l = str2.length; i < l; i++) {
        int2 = int2 * 26 + ALPHABET.indexOf(str2[i]) + 1;
      }
      return int2;
    };
    makeRangeInt = (start, end) => {
      if (end < start)
        return makeRangeInt(end, start);
      const range = [];
      while (start <= end) {
        range.push(start++);
      }
      return range;
    };
    makeRangePaddedInt = (start, end, paddingLength) => {
      return makeRangeInt(start, end).map((int2) => String(int2).padStart(paddingLength, "0"));
    };
    makeRangeAlpha = (start, end) => {
      return makeRangeInt(alpha2int(start), alpha2int(end)).map(int2alpha);
    };
  }
});

// node_modules/zeptomatch/dist/convert/grammar.js
var Escaped, Escape, Slash, Passthrough, NegationOdd, NegationEven, Negation, StarStarBetween, StarStarStart, StarStarEnd, StarStarNone, StarStar, StarDouble, StarSingle, Star, Question, ClassOpen, ClassClose, ClassNegation, ClassRange, ClassEscape, ClassPassthrough, ClassValue, Class, RangeOpen, RangeClose, RangeNumeric, RangeAlphaLower, RangeAlphaUpper, RangeValue, Range, BracesOpen, BracesClose, BracesComma, BracesEscape, BracesPassthrough, BracesNested, BracesValue, Braces, Grammar, grammar_default;
var init_grammar = __esm({
  "node_modules/zeptomatch/dist/convert/grammar.js"() {
    init_dist19();
    init_range();
    init_utils10();
    init_parser();
    Escaped = match(/\\./, identity2);
    Escape = match(/[$.*+?^(){}[\]\|]/, (char) => `\\${char}`);
    Slash = match(/[\\/]/, "[\\\\/]");
    Passthrough = match(/./, identity2);
    NegationOdd = match(/^(?:!!)*!(.*)$/, (_, glob) => `(?!^${parser_default(glob)}$).*?`);
    NegationEven = match(/^(!!)+/, "");
    Negation = or([NegationOdd, NegationEven]);
    StarStarBetween = match(/\/(\*\*\/)+/, "(?:[\\\\/].+[\\\\/]|[\\\\/])");
    StarStarStart = match(/^(\*\*\/)+/, "(?:^|.*[\\\\/])");
    StarStarEnd = match(/\/(\*\*)$/, "(?:[\\\\/].*|$)");
    StarStarNone = match(/\*\*/, ".*");
    StarStar = or([StarStarBetween, StarStarStart, StarStarEnd, StarStarNone]);
    StarDouble = match(/\*\/(?!\*\*\/|\*$)/, "[^\\\\/]*[\\\\/]");
    StarSingle = match(/\*/, "[^\\\\/]*");
    Star = or([StarDouble, StarSingle]);
    Question = match("?", "[^\\\\/]");
    ClassOpen = match("[", identity2);
    ClassClose = match("]", identity2);
    ClassNegation = match(/[!^]/, "^\\\\/");
    ClassRange = match(/[a-z]-[a-z]|[0-9]-[0-9]/i, identity2);
    ClassEscape = match(/[$.*+?^(){}[\|]/, (char) => `\\${char}`);
    ClassPassthrough = match(/[^\]]/, identity2);
    ClassValue = or([Escaped, ClassEscape, ClassRange, ClassPassthrough]);
    Class = and([ClassOpen, optional(ClassNegation), star(ClassValue), ClassClose]);
    RangeOpen = match("{", "(?:");
    RangeClose = match("}", ")");
    RangeNumeric = match(/(\d+)\.\.(\d+)/, (_, $1, $2) => makeRangePaddedInt(+$1, +$2, Math.min($1.length, $2.length)).join("|"));
    RangeAlphaLower = match(/([a-z]+)\.\.([a-z]+)/, (_, $1, $2) => makeRangeAlpha($1, $2).join("|"));
    RangeAlphaUpper = match(/([A-Z]+)\.\.([A-Z]+)/, (_, $1, $2) => makeRangeAlpha($1.toLowerCase(), $2.toLowerCase()).join("|").toUpperCase());
    RangeValue = or([RangeNumeric, RangeAlphaLower, RangeAlphaUpper]);
    Range = and([RangeOpen, RangeValue, RangeClose]);
    BracesOpen = match("{", "(?:");
    BracesClose = match("}", ")");
    BracesComma = match(",", "|");
    BracesEscape = match(/[$.*+?^(){[\]\|]/, (char) => `\\${char}`);
    BracesPassthrough = match(/[^}]/, identity2);
    BracesNested = lazy(() => Braces);
    BracesValue = or([StarStar, Star, Question, Class, Range, BracesNested, Escaped, BracesEscape, BracesComma, BracesPassthrough]);
    Braces = and([BracesOpen, star(BracesValue), BracesClose]);
    Grammar = star(or([Negation, StarStar, Star, Question, Class, Range, Braces, Escaped, Escape, Slash, Passthrough]));
    grammar_default = Grammar;
  }
});

// node_modules/zeptomatch/dist/convert/parser.js
var parser, parser_default;
var init_parser = __esm({
  "node_modules/zeptomatch/dist/convert/parser.js"() {
    init_utils10();
    init_grammar();
    parser = makeParser(grammar_default);
    parser_default = parser;
  }
});

// node_modules/zeptomatch/dist/normalize/grammar.js
var Escaped2, Passthrough2, StarStarStar, StarStarNoLeft, StarStarNoRight, Grammar2, grammar_default2;
var init_grammar2 = __esm({
  "node_modules/zeptomatch/dist/normalize/grammar.js"() {
    init_dist19();
    init_utils10();
    Escaped2 = match(/\\./, identity2);
    Passthrough2 = match(/./, identity2);
    StarStarStar = match(/\*\*\*+/, "*");
    StarStarNoLeft = match(/([^/{[(!])\*\*/, (_, $1) => `${$1}*`);
    StarStarNoRight = match(/(^|.)\*\*(?=[^*/)\]}])/, (_, $1) => `${$1}*`);
    Grammar2 = star(or([Escaped2, StarStarStar, StarStarNoLeft, StarStarNoRight, Passthrough2]));
    grammar_default2 = Grammar2;
  }
});

// node_modules/zeptomatch/dist/normalize/parser.js
var parser2, parser_default2;
var init_parser2 = __esm({
  "node_modules/zeptomatch/dist/normalize/parser.js"() {
    init_utils10();
    init_grammar2();
    parser2 = makeParser(grammar_default2);
    parser_default2 = parser2;
  }
});

// node_modules/zeptomatch/dist/index.js
var zeptomatch, dist_default18;
var init_dist20 = __esm({
  "node_modules/zeptomatch/dist/index.js"() {
    init_parser();
    init_parser2();
    init_utils10();
    zeptomatch = (glob, path17) => {
      if (Array.isArray(glob)) {
        const res = glob.map(zeptomatch.compile);
        const isMatch = res.some((re) => re.test(path17));
        return isMatch;
      } else {
        const re = zeptomatch.compile(glob);
        const isMatch = re.test(path17);
        return isMatch;
      }
    };
    zeptomatch.compile = memoize3((glob) => {
      return new RegExp(`^${parser_default(parser_default2(glob))}[\\\\/]?$`, "s");
    });
    dist_default18 = zeptomatch;
  }
});

// node_modules/zeptomatch-explode/dist/explode_start.js
var SIMPLE_RE, explodeStart, explode_start_default;
var init_explode_start = __esm({
  "node_modules/zeptomatch-explode/dist/explode_start.js"() {
    SIMPLE_RE = /(\/?)([ a-zA-Z0-9._-]*)(?:\{([ a-zA-Z0-9._-]+(?:,[ a-zA-Z0-9._-]+)*)\})?([ a-zA-Z0-9._-]*)(\/(?=.))/gsy;
    explodeStart = (glob) => {
      let index = 0;
      let length = glob.length;
      let statics = [];
      while (index < length) {
        SIMPLE_RE.lastIndex = index;
        const match2 = SIMPLE_RE.exec(glob);
        if (!match2)
          break;
        const [_, slash, prefix, multiple, suffix] = match2;
        if (!prefix && !multiple && !suffix)
          break;
        const values = multiple ? multiple.split(",").map((value) => `${slash}${prefix}${value}${suffix}`) : [`${slash}${prefix}${suffix}`];
        statics = statics.length ? statics.flatMap((prefix2) => values.map((value) => `${prefix2}/${value}`)) : values;
        index = SIMPLE_RE.lastIndex;
      }
      const dynamic = index ? glob.slice(index) : glob;
      return { statics, dynamic };
    };
    explode_start_default = explodeStart;
  }
});

// node_modules/zeptomatch-explode/dist/explode_end.js
var SIMPLE_RE2, explodeEnd, explode_end_default;
var init_explode_end = __esm({
  "node_modules/zeptomatch-explode/dist/explode_end.js"() {
    SIMPLE_RE2 = /(^|\/)(\*?)([ a-zA-Z0-9._-]*)(?:\{([ a-zA-Z0-9._-]+(?:,[ a-zA-Z0-9._-]+)*)\})?([ a-zA-Z0-9._-]*)(\*?)$/;
    explodeEnd = (glob) => {
      const match2 = SIMPLE_RE2.exec(glob);
      if (match2) {
        const [_, slash, starStart, prefix, multiple, suffix, starEnd] = match2;
        if (prefix || multiple || suffix) {
          const flexibleStart = !!starStart;
          const flexibleEnd = !!starEnd;
          const statics = multiple ? multiple.split(",").map((value) => `${prefix}${value}${suffix}`) : [`${prefix}${suffix}`];
          const head = glob.slice(0, match2.index);
          const dynamic = head ? `${head}/*` : "*";
          return { flexibleStart, flexibleEnd, statics, dynamic };
        } else if (starStart || starEnd) {
          const flexibleStart = true;
          const flexibleEnd = true;
          const statics = [];
          const dynamic = glob;
          return { flexibleStart, flexibleEnd, statics, dynamic };
        }
      }
      return { flexibleStart: false, flexibleEnd: false, statics: [], dynamic: glob };
    };
    explode_end_default = explodeEnd;
  }
});

// node_modules/zeptomatch-explode/dist/index.js
var init_dist21 = __esm({
  "node_modules/zeptomatch-explode/dist/index.js"() {
    init_explode_start();
    init_explode_end();
  }
});

// node_modules/zeptomatch-is-static/dist/index.js
var isStatic, dist_default19;
var init_dist22 = __esm({
  "node_modules/zeptomatch-is-static/dist/index.js"() {
    isStatic = /* @__PURE__ */ (() => {
      const re = /^(?:\\$|\\.|[^*?!^{}[\]\\])*$/s;
      return (glob) => {
        return re.test(glob);
      };
    })();
    dist_default19 = isStatic;
  }
});

// node_modules/zeptomatch-unescape/dist/index.js
var unescape, dist_default20;
var init_dist23 = __esm({
  "node_modules/zeptomatch-unescape/dist/index.js"() {
    unescape = /* @__PURE__ */ (() => {
      const re = /\\(.)/gs;
      return (glob) => {
        return glob.replace(re, "$1");
      };
    })();
    dist_default20 = unescape;
  }
});

// node_modules/tiny-readdir-glob/dist/utils.js
import path7 from "path";
var castArray4, globExplode, globsExplode, globCompile, globsCompile, globsPartition, ignoreCompile, intersection, isPathSep, isString2, uniq2, uniqFlat, uniqMergeConcat;
var init_utils11 = __esm({
  "node_modules/tiny-readdir-glob/dist/utils.js"() {
    init_dist20();
    init_dist21();
    init_dist22();
    init_dist23();
    castArray4 = (value) => {
      return Array.isArray(value) ? value : [value];
    };
    globExplode = (glob) => {
      if (dist_default19(glob)) {
        return [[dist_default20(glob)], "**/*"];
      } else {
        const { statics, dynamic } = explode_start_default(glob);
        return [statics, dynamic];
      }
    };
    globsExplode = (globs) => {
      const results = [];
      for (const glob of globs) {
        const [paths, pathsGlob] = globExplode(glob);
        if (!paths.length) {
          paths.push("");
        }
        for (const path17 of paths) {
          const existing = results.find((result) => result[0].includes(path17));
          if (existing) {
            if (!existing[1].includes(pathsGlob)) {
              existing[1].push(pathsGlob);
            }
          } else {
            results.push([[path17], [pathsGlob]]);
          }
        }
      }
      return results;
    };
    globCompile = (glob) => {
      if (!glob || glob === "**/*") {
        return () => true;
      }
      const { flexibleStart, flexibleEnd, statics, dynamic } = explode_end_default(glob);
      if (dynamic === "**/*" && statics.length && !flexibleEnd) {
        return (rootPath, targetPath) => {
          for (let i = 0, l = statics.length; i < l; i++) {
            const end = statics[i];
            if (!targetPath.endsWith(end))
              continue;
            if (flexibleStart)
              return true;
            if (targetPath.length === end.length)
              return true;
            if (isPathSep(targetPath[targetPath.length - end.length - 1]))
              return true;
          }
          return false;
        };
      } else {
        const re = dist_default18.compile(glob);
        return (rootPath, targetPath) => {
          return re.test(path7.relative(rootPath, targetPath));
        };
      }
    };
    globsCompile = (globs) => {
      const fns = globs.map(globCompile);
      return (rootPath, targetPath) => fns.some((fn) => fn(rootPath, targetPath));
    };
    globsPartition = (globs) => {
      const positives = [];
      const negatives = [];
      const bangsRe = /^!+/;
      if (globs.length) {
        for (const glob of globs) {
          const match2 = glob.match(bangsRe);
          if (match2) {
            const bangsNr = match2[0].length;
            const bucket = bangsNr % 2 === 0 ? positives : negatives;
            bucket.push(glob.slice(bangsNr));
          } else {
            positives.push(glob);
          }
        }
        if (!positives.length) {
          positives.push("**");
        }
      }
      return [positives, negatives];
    };
    ignoreCompile = (rootPath, ignore) => {
      if (!ignore)
        return;
      return castArray4(ignore).map((ignore2) => {
        if (!isString2(ignore2))
          return ignore2;
        const fn = globCompile(ignore2);
        return (targetPath) => fn(rootPath, targetPath);
      });
    };
    intersection = (sets) => {
      if (sets.length === 1)
        return sets[0];
      const result = /* @__PURE__ */ new Set();
      for (let i = 0, l = sets.length; i < l; i++) {
        const set3 = sets[i];
        for (const value of set3) {
          result.add(value);
        }
      }
      return result;
    };
    isPathSep = (char) => {
      return char === "/" || char === "\\";
    };
    isString2 = (value) => {
      return typeof value === "string";
    };
    uniq2 = (values) => {
      if (values.length < 2)
        return values;
      return Array.from(new Set(values));
    };
    uniqFlat = (values) => {
      if (values.length === 1)
        return values[0];
      return uniq2(values.flat());
    };
    uniqMergeConcat = (values) => {
      if (values.length === 1)
        return values[0];
      const merged = {};
      for (let i = 0, l = values.length; i < l; i++) {
        const value = values[i];
        for (const key2 in value) {
          const prev = merged[key2];
          const next = Array.isArray(prev) ? prev.concat(value[key2]) : value[key2];
          merged[key2] = next;
        }
      }
      for (const key2 in merged) {
        merged[key2] = uniq2(merged[key2]);
      }
      return merged;
    };
  }
});

// node_modules/tiny-readdir-glob/dist/index.js
import path8 from "path";
import process10 from "process";
var readdirGlob, dist_default21;
var init_dist24 = __esm({
  "node_modules/tiny-readdir-glob/dist/index.js"() {
    init_dist18();
    init_utils11();
    readdirGlob = async (glob, options) => {
      const [globsPositive, globsNegative] = globsPartition(castArray4(glob));
      const cwd = (options == null ? void 0 : options.cwd) ?? process10.cwd();
      const ignore = [...castArray4((options == null ? void 0 : options.ignore) ?? []), ...globsNegative];
      const bucketDirectories = [];
      const bucketFiles = [];
      const bucketSymlinks = [];
      const bucketDirectoriesFound = [];
      const bucketFilesFound = [];
      const bucketSymlinksFound = [];
      const bucketDirectoriesFoundNames = [];
      const bucketFilesFoundNames = [];
      const bucketSymlinksFoundNames = [];
      const bucketDirectoriesFoundNamesToPaths = [];
      const bucketFilesFoundNamesToPaths = [];
      const bucketSymlinksFoundNamesToPaths = [];
      for (const [folders, foldersGlobs] of globsExplode(globsPositive)) {
        const isMatch = globsCompile(foldersGlobs);
        for (const folder of folders) {
          const rootPath = path8.join(cwd, folder).replace(/\/$/, "");
          const isIgnored = ignoreCompile(rootPath, ignore);
          const isRelativeMatch = (targetPath) => isMatch(rootPath, targetPath);
          const result = await dist_default17(rootPath, {
            depth: options == null ? void 0 : options.depth,
            limit: options == null ? void 0 : options.limit,
            followSymlinks: options == null ? void 0 : options.followSymlinks,
            ignore: isIgnored,
            signal: options == null ? void 0 : options.signal,
            onDirents: options == null ? void 0 : options.onDirents
          });
          bucketDirectories.push(result.directories.filter(isRelativeMatch));
          bucketFiles.push(result.files.filter(isRelativeMatch));
          bucketSymlinks.push(result.symlinks.filter(isRelativeMatch));
          bucketDirectoriesFound.push(result.directories);
          bucketFilesFound.push(result.files);
          bucketSymlinksFound.push(result.symlinks);
          bucketDirectoriesFoundNames.push(result.directoriesNames);
          bucketFilesFoundNames.push(result.filesNames);
          bucketSymlinksFoundNames.push(result.symlinksNames);
          bucketDirectoriesFoundNamesToPaths.push(result.directoriesNamesToPaths);
          bucketFilesFoundNamesToPaths.push(result.filesNamesToPaths);
          bucketSymlinksFoundNamesToPaths.push(result.symlinksNamesToPaths);
        }
      }
      const directories = uniqFlat(bucketDirectories);
      const files = uniqFlat(bucketFiles);
      const symlinks = uniqFlat(bucketSymlinks);
      const directoriesFound = uniqFlat(bucketDirectoriesFound);
      const filesFound = uniqFlat(bucketFilesFound);
      const symlinksFound = uniqFlat(bucketSymlinksFound);
      const directoriesFoundNames = intersection(bucketDirectoriesFoundNames);
      const filesFoundNames = intersection(bucketFilesFoundNames);
      const symlinksFoundNames = intersection(bucketSymlinksFoundNames);
      const directoriesFoundNamesToPaths = uniqMergeConcat(bucketDirectoriesFoundNamesToPaths);
      const filesFoundNamesToPaths = uniqMergeConcat(bucketFilesFoundNamesToPaths);
      const symlinksFoundNamesToPaths = uniqMergeConcat(bucketSymlinksFoundNamesToPaths);
      return { directories, files, symlinks, directoriesFound, filesFound, symlinksFound, directoriesFoundNames, filesFoundNames, symlinksFoundNames, directoriesFoundNamesToPaths, filesFoundNamesToPaths, symlinksFoundNamesToPaths };
    };
    dist_default21 = readdirGlob;
  }
});

// node_modules/zeptomatch-escape/dist/index.js
var escape, dist_default22;
var init_dist25 = __esm({
  "node_modules/zeptomatch-escape/dist/index.js"() {
    escape = /* @__PURE__ */ (() => {
      const re = /(\\.)|([*?!^{}[\]])|(.)/gs;
      const replacer = (_, $1, $2, $3) => $1 || $3 || `\\${$2}`;
      return (value) => {
        return value.replace(re, replacer);
      };
    })();
    dist_default22 = escape;
  }
});

// node_modules/@prettier/cli/dist/utils.js
import crypto from "crypto";
import fs7 from "fs";
import path9 from "path";
import process11 from "process";
import { text as stream2text } from "stream/consumers";
import url from "url";
function castArray5(value) {
  return isArray3(value) ? value : [value];
}
function fastJoinedPath(folderPath, fileName) {
  return `${folderPath}${path9.sep}${fileName}`;
}
function fastRelativePath(fromPath, toPath) {
  if (toPath.startsWith(fromPath)) {
    if (toPath[fromPath.length] === path9.sep) {
      return toPath.slice(fromPath.length + 1);
    }
  }
  return path9.relative(fromPath, toPath);
}
function fastRelativeChildPath(fromPath, toPath) {
  if (toPath.startsWith(fromPath)) {
    if (toPath[fromPath.length] === path9.sep) {
      return toPath.slice(fromPath.length + 1);
    }
  }
}
function findLastIndex(array, predicate) {
  for (let i = array.length - 1; i >= 0; i--) {
    if (predicate(array[i], i, array))
      return i;
  }
  return -1;
}
function getCachePath(rootPath) {
  const nodeModulesPaths = path9.join(rootPath, "node_modules");
  const cachePath = path9.join(nodeModulesPaths, ".cache", "prettier", ".prettier-caches");
  return cachePath;
}
function getDirectoryPaths(rootPath, withNodeModules) {
  const ignoreGlob = `**/{.git,.sl,.svn,.hg,.DS_Store,Thumbs.db${withNodeModules ? "" : ",node_modules"}}`;
  const ignoreRe = dist_default18.compile(ignoreGlob);
  const ignore = (targetPath) => {
    return ignoreRe.test(path9.relative(rootPath, targetPath));
  };
  return dist_default17(rootPath, {
    followSymlinks: false,
    ignore
  });
}
function getExpandedFoldersPaths(foldersPaths, untilPath = "/") {
  const knownPaths = new Set(foldersPaths);
  const expandedPaths = /* @__PURE__ */ new Set();
  const extraPaths = /* @__PURE__ */ new Set();
  for (let i = 0, l = foldersPaths.length; i < l; i++) {
    let folderPath = foldersPaths[i];
    while (true) {
      if (expandedPaths.has(folderPath))
        break;
      if (folderPath === untilPath)
        break;
      expandedPaths.add(folderPath);
      folderPath = path9.dirname(folderPath);
      if (!knownPaths.has(folderPath)) {
        extraPaths.add(folderPath);
      }
    }
  }
  return [[...expandedPaths], [...extraPaths]];
}
async function getFolderChildrenPaths(folderPath) {
  const dirents = await fs7.promises.readdir(folderPath, { withFileTypes: true });
  const childrenPaths = dirents.map((dirent) => fastJoinedPath(folderPath, dirent.name));
  return childrenPaths;
}
async function getFoldersChildrenPaths(foldersPaths) {
  const childrensPaths = await Promise.all(foldersPaths.map(getFolderChildrenPaths));
  const childrenPaths = childrensPaths.flat();
  return childrenPaths;
}
function getGlobPaths(rootPath, globs, withNodeModules) {
  return dist_default21(globs, {
    cwd: rootPath,
    followSymlinks: false,
    ignore: `**/{.git,.sl,.svn,.hg,.DS_Store,Thumbs.db${withNodeModules ? "" : ",node_modules"}}`
  });
}
async function getModule(modulePath) {
  const moduleExports = await import(url.pathToFileURL(modulePath).href);
  const module = moduleExports.default || moduleExports.exports || moduleExports;
  return module;
}
function getModulePath(name, rootPath) {
  const rootUrl = url.pathToFileURL(rootPath);
  const moduleUrl = moduleResolve(name, rootUrl);
  const modulePath = url.fileURLToPath(moduleUrl);
  return modulePath;
}
function identity3(value) {
  return value;
}
async function getPluginOrExit(name) {
  try {
    return await getPlugin(name);
  } catch {
    exit_default(`The plugin "${name}" could not be loaded`);
  }
}
function getPluginPath(name) {
  const rootPath = path9.join(process11.cwd(), "index.js");
  try {
    return getModulePath(`./${name}`, rootPath);
  } catch {
    return getModulePath(name, rootPath);
  }
}
function getPluginVersion(name) {
  const pluginPath = getPluginPath(name);
  const parentPath = path9.dirname(pluginPath);
  const pkg = dist_default2("package.json", parentPath);
  if (!pkg || !pkg.content.version) {
    return null;
  } else {
    return pkg.content.version;
  }
}
function getPluginsVersions(names) {
  const pluginsVersions = names.map(getPluginVersion);
  return pluginsVersions;
}
function getProjectPath(rootPath) {
  function isProjectPath(folderPath) {
    const gitPath = path9.join(folderPath, ".git");
    if (fs7.existsSync(gitPath))
      return true;
    const hgPath = path9.join(folderPath, ".hg");
    if (fs7.existsSync(hgPath))
      return true;
    const svnPath = path9.join(folderPath, ".svn");
    if (fs7.existsSync(svnPath))
      return true;
    const slPath = path9.join(folderPath, ".sl");
    if (fs7.existsSync(slPath))
      return true;
    return false;
  }
  let currentPath = rootPath;
  while (true) {
    if (isProjectPath(currentPath)) {
      return currentPath;
    } else {
      const currentPathNext = path9.dirname(currentPath);
      if (currentPath === currentPathNext) {
        return rootPath;
      } else {
        currentPath = currentPathNext;
      }
    }
  }
}
function getStats(targetPath) {
  try {
    return fs7.statSync(targetPath);
  } catch {
    return;
  }
}
async function getTargetsPaths(rootPath, globs, withNodeModules) {
  const targetFiles = [];
  const targetFilesNames = [];
  const targetFilesNamesToPaths = {};
  const targetDirectories = [];
  const targetGlobs = [];
  for (const glob of globs) {
    const filePath = path9.resolve(rootPath, glob);
    const fileStats = getStats(filePath);
    if (fileStats == null ? void 0 : fileStats.isFile()) {
      const fileName = path9.basename(filePath);
      targetFiles.push(filePath);
      targetFilesNames.push(fileName);
      targetFilesNamesToPaths.propertyIsEnumerable(fileName) || (targetFilesNamesToPaths[fileName] = []);
      targetFilesNamesToPaths[fileName].push(filePath);
    } else if (fileStats == null ? void 0 : fileStats.isDirectory()) {
      targetDirectories.push(filePath);
    } else {
      targetGlobs.push(glob);
    }
  }
  const globResult = await getGlobPaths(rootPath, targetGlobs, withNodeModules);
  const globResultFiles = globResult.files;
  const globResultFilesFoundNames = [...globResult.filesFoundNames];
  const directoriesResults = await Promise.all(targetDirectories.map((targetPath) => getDirectoryPaths(targetPath, withNodeModules)));
  const directoriesResultsFiles = directoriesResults.map((result) => result.files);
  const directoriesResultsFilesFoundNames = directoriesResults.map((result) => [...result.filesNames]);
  const foundFiles = uniqChunks(globResultFiles, ...directoriesResultsFiles);
  const foundFilesNames = uniqChunks(globResultFilesFoundNames, ...directoriesResultsFilesFoundNames);
  const filesPaths = [...without2(targetFiles, foundFiles), ...foundFiles];
  const filesNames = [...without2(targetFilesNames, foundFilesNames), ...foundFilesNames];
  const filesNamesToPaths = globResult.filesFoundNamesToPaths;
  for (const fileName in targetFilesNamesToPaths) {
    const prev = filesNamesToPaths[fileName];
    const next = Array.isArray(prev) ? prev.concat(targetFilesNamesToPaths[fileName]) : targetFilesNamesToPaths[fileName];
    filesNamesToPaths[fileName] = uniq3(next);
  }
  const filesExplicitPaths = targetFiles;
  const globFilesFoundPaths = globResult.filesFound;
  const directoryFilesFoundPaths = directoriesResultsFiles.flat();
  const filesFoundPaths = [...globFilesFoundPaths, ...directoryFilesFoundPaths];
  const globFoldersFoundPaths = globResult.directoriesFound;
  const directoryFoldersFoundPaths = directoriesResults.flatMap((result) => result.directories);
  const foldersFoundPaths = [rootPath, ...globFoldersFoundPaths, ...directoryFoldersFoundPaths];
  return [filesPaths, filesNames, filesNamesToPaths, filesExplicitPaths, filesFoundPaths, foldersFoundPaths];
}
function isArray3(value) {
  return Array.isArray(value);
}
function isBoolean2(value) {
  return typeof value === "boolean";
}
function isFunction3(value) {
  return typeof value === "function";
}
function isInteger(value) {
  return Number.isInteger(value);
}
function isIntegerInRange(value, min = -Infinity, max = Infinity, step = 1) {
  return isInteger(value) && value >= min && value <= max && value % step === 0;
}
function isNull2(value) {
  return value === null;
}
function isNumber2(value) {
  return typeof value === "number";
}
function isObject2(value) {
  if (value === null)
    return false;
  const type2 = typeof value;
  return type2 === "object" || type2 === "function";
}
function isString3(value) {
  return typeof value === "string";
}
function isTruthy(value) {
  return !!value;
}
function isUndefined4(value) {
  return typeof value === "undefined";
}
function negate(fn) {
  return (...args) => {
    return !fn(...args);
  };
}
function noop2() {
  return;
}
async function normalizeOptions(options, targets) {
  if (!isObject2(options))
    exit_default("Invalid options object");
  const targetsGlobs = targets.filter(isString3);
  const targetsStatic = "--" in options && Array.isArray(options["--"]) ? options["--"].filter(isString3).map(dist_default22) : [];
  const globs = [...targetsGlobs, ...targetsStatic];
  const stdin = await getStdin();
  if (!isString3(stdin) && !globs.length)
    exit_default("Expected at least one target file/dir/glob");
  const check = "check" in options && !!options.check;
  const list = "listDifferent" in options && !!options.listDifferent;
  const write = "write" in options && !!options.write;
  const dump2 = !check && !list && !write;
  if (check && list)
    exit_default('The "--check" and "--list-different" flags cannot be used together');
  if (check && write)
    exit_default('The "--check" and "--write" flags cannot be used together');
  if (list && write)
    exit_default('The "--list-different" and "--write" flags cannot be used together');
  const config = "config" in options ? !!options.config : true;
  const configPath = "configPath" in options && isString3(options.configPath) ? [options.configPath] : void 0;
  const editorConfig = "editorconfig" in options ? !!options.editorconfig : true;
  const ignore = "ignore" in options ? !!options.ignore : true;
  const ignorePath = "ignorePath" in options && isArray3(options.ignorePath) && options.ignorePath.every(isString3) ? options.ignorePath : void 0;
  const withNodeModules = "withNodeModules" in options ? !!options.withNodeModules : false;
  const cache3 = "cache" in options ? !!options.cache : true;
  const cacheLocation = "cacheLocation" in options && isString3(options.cacheLocation) ? options.cacheLocation : void 0;
  const errorOnUnmatchedPattern = "errorOnUnmatchedPattern" in options ? !!options.errorOnUnmatchedPattern : true;
  const ignoreUnknown = "ignoreUnknown" in options && isBoolean2(options.ignoreUnknown) ? !!options.ignoreUnknown : globs.some(dist_default19);
  const logLevel = "logLevel" in options ? options.logLevel || "log" : "log";
  const parallel = "parallel" in options && !!options.parallel;
  const parallelWorkers = "parallelWorkers" in options && Math.round(Number(options.parallelWorkers)) || 0;
  const stdinFilepath = "stdinFilepath" in options && isString3(options.stdinFilepath) ? options.stdinFilepath : void 0;
  const contextOptions = normalizeContextOptions(options);
  const formatOptions = normalizeFormatOptions(options);
  return {
    globs,
    check,
    dump: dump2,
    list,
    write,
    config,
    configPath,
    editorConfig,
    ignore,
    ignorePath,
    withNodeModules,
    cache: cache3,
    cacheLocation,
    errorOnUnmatchedPattern,
    ignoreUnknown,
    logLevel,
    parallel,
    parallelWorkers,
    stdinFilepath,
    contextOptions,
    formatOptions
  };
}
function normalizeContextOptions(options) {
  if (!isObject2(options))
    exit_default("Invalid options object");
  const contextOptions = {};
  if ("cursorOffset" in options) {
    const value = Number(options.cursorOffset);
    if (isInteger(value) && value >= 0) {
      contextOptions.cursorOffset = value;
    }
  }
  if ("rangeEnd" in options) {
    const value = Number(options.rangeEnd);
    if (isInteger(value) && value >= 0) {
      contextOptions.rangeEnd = value;
    }
  }
  if ("rangeStart" in options) {
    const value = Number(options.rangeStart);
    if (isInteger(value) && value >= 0) {
      contextOptions.rangeStart = value;
    }
  }
  return contextOptions;
}
function normalizeFormatOptions(options) {
  if (!isObject2(options))
    exit_default("Invalid options object");
  const formatOptions = {};
  if ("experimentalOperatorPosition" in options) {
    const value = options.experimentalOperatorPosition;
    if (value === "start" || value === "end") {
      formatOptions.experimentalOperatorPosition = value;
    }
  }
  if ("experimentalTernaries" in options) {
    const value = options.experimentalTernaries;
    if (isBoolean2(value)) {
      formatOptions.experimentalTernaries = value;
    }
  }
  if ("arrowParens" in options) {
    const value = options.arrowParens;
    if (value === "avoid" || value === "always") {
      formatOptions.arrowParens = value;
    }
  }
  if ("bracketSameLine" in options) {
    const value = options.bracketSameLine;
    if (isBoolean2(value)) {
      formatOptions.bracketSameLine = value;
    }
  }
  if ("bracketSpacing" in options) {
    const value = options.bracketSpacing;
    if (isBoolean2(value)) {
      formatOptions.bracketSpacing = value;
    }
  }
  if ("embeddedLanguageFormatting" in options) {
    const value = options.embeddedLanguageFormatting;
    if (value === "auto" || value === "off") {
      formatOptions.embeddedLanguageFormatting = value;
    }
  }
  if ("endOfLine" in options) {
    const value = options.endOfLine;
    if (value === "lf" || value === "crlf" || value === "cr" || value === "auto") {
      formatOptions.endOfLine = value;
    }
  }
  if ("htmlWhitespaceSensitivity" in options) {
    const value = options.htmlWhitespaceSensitivity;
    if (value === "css" || value === "strict" || value === "ignore") {
      formatOptions.htmlWhitespaceSensitivity = value;
    }
  }
  if ("insertPragma" in options) {
    const value = options.insertPragma;
    if (isBoolean2(value)) {
      formatOptions.insertPragma = value;
    }
  }
  if ("jsxSingleQuote" in options) {
    const value = options.jsxSingleQuote;
    if (isBoolean2(value)) {
      formatOptions.jsxSingleQuote = value;
    }
  }
  if ("objectWrap" in options) {
    const value = options.objectWrap;
    if (value === "preserve" || value === "collapse") {
      formatOptions.objectWrap = value;
    }
  }
  if ("parser" in options) {
    const value = options.parser;
    if (isString3(value)) {
      formatOptions.parser = value;
    }
  }
  if ("plugin" in options || "plugins" in options) {
    const value = options["plugin"] || options["plugins"];
    if (isArray3(value) && value.every(isString3)) {
      formatOptions.plugins = value;
    } else if (isString3(value)) {
      formatOptions.plugins = [value];
    } else if (!isUndefined4(value)) {
      exit_default("Non-string plugin specifiers are not supported yet");
    }
  }
  if ("printWidth" in options) {
    const value = Number(options.printWidth);
    if (isInteger(value) && value >= 0) {
      formatOptions.printWidth = value;
    }
  }
  if ("proseWrap" in options) {
    const value = options.proseWrap;
    if (value === "always" || value === "never" || value === "preserve") {
      formatOptions.proseWrap = value;
    }
  }
  if ("quoteProps" in options) {
    const value = options.quoteProps;
    if (value === "as-needed" || value === "consistent" || value === "preserve") {
      formatOptions.quoteProps = value;
    }
  }
  if ("requirePragma" in options) {
    const value = options.requirePragma;
    if (isBoolean2(value)) {
      formatOptions.requirePragma = value;
    }
  }
  if ("semi" in options) {
    const value = options.semi;
    if (isBoolean2(value)) {
      formatOptions.semi = value;
    }
  }
  if ("singleAttributePerLine" in options) {
    const value = options.singleAttributePerLine;
    if (isBoolean2(value)) {
      formatOptions.singleAttributePerLine = value;
    }
  }
  if ("singleQuote" in options) {
    const value = options.singleQuote;
    if (isBoolean2(value)) {
      formatOptions.singleQuote = value;
    }
  }
  if ("tabWidth" in options) {
    const value = Number(options.tabWidth);
    if (isInteger(value) && value >= 0) {
      formatOptions.tabWidth = value;
    }
  }
  if ("trailingComma" in options) {
    const value = options.trailingComma;
    if (value === "all" || value === "es5" || value === "none") {
      formatOptions.trailingComma = value;
    }
  }
  if ("useTabs" in options) {
    const value = options.useTabs;
    if (isBoolean2(value)) {
      formatOptions.useTabs = value;
    }
  }
  if ("vueIndentScriptAndStyle" in options) {
    const value = options.vueIndentScriptAndStyle;
    if (isBoolean2(value)) {
      formatOptions.vueIndentScriptAndStyle = value;
    }
  }
  return formatOptions;
}
function normalizePluginOptions(options, names) {
  if (!isObject2(options))
    exit_default("Invalid options object");
  const config = {};
  for (let i = 0, l = names.length; i < l; i++) {
    const name = names[i];
    const value = options[name];
    if (isUndefined4(value))
      continue;
    config[name] = value;
  }
  return config;
}
function normalizePrettierOptions(options, folderPath) {
  if (!isObject2(options))
    exit_default("Invalid options object");
  const config = normalizeFormatOptions(options);
  if ("overrides" in options && isArray3(options.overrides)) {
    const overridesRaw = options.overrides;
    for (let i = 0, l = overridesRaw.length; i < l; i++) {
      const overrideRaw = overridesRaw[i];
      if (!isObject2(overrideRaw))
        continue;
      if (!("files" in overrideRaw))
        continue;
      if (!isString3(overrideRaw.files) && (!isArray3(overrideRaw.files) || !overrideRaw.files.every(isString3)))
        continue;
      if (isArray3(overrideRaw.files) && !overrideRaw.files.length)
        continue;
      if (!("options" in overrideRaw))
        continue;
      if (!isObject2(overrideRaw.options))
        continue;
      const overrides = config.overrides || (config.overrides = []);
      const filesPositive = castArray5(overrideRaw.files);
      const filesNegative = "filesNegative" in overrideRaw && (isString3(overrideRaw.filesNegative) || isArray3(overrideRaw.filesNegative) && overrideRaw.filesNegative.every(isString3)) ? castArray5(overrideRaw.filesNegative) : [];
      const folder = folderPath;
      const options2 = normalizeFormatOptions(overrideRaw.options);
      overrides.push({ filesPositive, filesNegative, folder, options: options2 });
    }
  }
  return config;
}
function omit(object, keys) {
  const clone = { ...object };
  for (let i = 0, l = keys.length; i < l; i++) {
    delete clone[keys[i]];
  }
  return clone;
}
function pluralize(value, length) {
  return `${value}${length === 1 ? "" : "s"}`;
}
function resolve2(value) {
  return isFunction3(value) ? value() : value;
}
function sha1hex(value) {
  return crypto.createHash("sha1").update(value).digest("hex");
}
function sha1base64(value) {
  return crypto.createHash("sha1").update(value).digest("base64");
}
function someOf(fns) {
  return (arg) => {
    return fns.some((fn) => fn(arg));
  };
}
function trimFinalNewline(value) {
  return value.replace(/(\r?\n|\r)$/, "");
}
function uniq3(values) {
  if (values.length < 2)
    return values;
  return Array.from(new Set(values));
}
function uniqChunks(...chunks) {
  const chunksNonEmpty = chunks.filter((chunk) => chunk.length);
  if (chunksNonEmpty.length === 0) {
    return [];
  } else if (chunksNonEmpty.length === 1) {
    return chunksNonEmpty[0];
  } else {
    return uniq3(chunks.flat());
  }
}
function without2(values, exclude) {
  if (!values.length)
    return values;
  if (!exclude.length)
    return values;
  const excludeSet = new Set(exclude);
  return values.filter((value) => !excludeSet.has(value));
}
function zipObjectUnless(keys, values, unless) {
  const map2 = {};
  for (let i = 0, l = keys.length; i < l; i++) {
    const value = values[i];
    if (!unless(value)) {
      map2[keys[i]] = value;
    }
  }
  return map2;
}
var getPlugin, getStdin, normalizePathSeparatorsToPosix;
var init_utils12 = __esm({
  "node_modules/@prettier/cli/dist/utils.js"() {
    init_dist2();
    init_dist13();
    init_import_meta_resolve();
    init_dist14();
    init_dist15();
    init_dist12();
    init_dist18();
    init_dist24();
    init_dist20();
    init_dist25();
    init_dist22();
    getPlugin = dist_default13((name) => {
      const pluginPath = getPluginPath(name);
      const plugin = getModule(pluginPath);
      return plugin;
    });
    getStdin = dist_default12(async () => {
      if (!process11.stdin.isTTY) {
        const stdin = stream2text(process11.stdin);
        const fallback = dist_default14(1e3, void 0);
        return Promise.race([stdin, fallback]);
      }
    });
    normalizePathSeparatorsToPosix = (() => {
      if (path9.sep === "\\") {
        return (filePath) => {
          return filePath.replaceAll("\\", "/");
        };
      } else {
        return identity3;
      }
    })();
  }
});

// node_modules/binary-extensions/binary-extensions.json
var require_binary_extensions = __commonJS({
  "node_modules/binary-extensions/binary-extensions.json"(exports, module) {
    module.exports = [
      "3dm",
      "3ds",
      "3g2",
      "3gp",
      "7z",
      "a",
      "aac",
      "adp",
      "afdesign",
      "afphoto",
      "afpub",
      "ai",
      "aif",
      "aiff",
      "alz",
      "ape",
      "apk",
      "appimage",
      "ar",
      "arj",
      "asf",
      "au",
      "avi",
      "bak",
      "baml",
      "bh",
      "bin",
      "bk",
      "bmp",
      "btif",
      "bz2",
      "bzip2",
      "cab",
      "caf",
      "cgm",
      "class",
      "cmx",
      "cpio",
      "cr2",
      "cur",
      "dat",
      "dcm",
      "deb",
      "dex",
      "djvu",
      "dll",
      "dmg",
      "dng",
      "doc",
      "docm",
      "docx",
      "dot",
      "dotm",
      "dra",
      "DS_Store",
      "dsk",
      "dts",
      "dtshd",
      "dvb",
      "dwg",
      "dxf",
      "ecelp4800",
      "ecelp7470",
      "ecelp9600",
      "egg",
      "eol",
      "eot",
      "epub",
      "exe",
      "f4v",
      "fbs",
      "fh",
      "fla",
      "flac",
      "flatpak",
      "fli",
      "flv",
      "fpx",
      "fst",
      "fvt",
      "g3",
      "gh",
      "gif",
      "graffle",
      "gz",
      "gzip",
      "h261",
      "h263",
      "h264",
      "icns",
      "ico",
      "ief",
      "img",
      "ipa",
      "iso",
      "jar",
      "jpeg",
      "jpg",
      "jpgv",
      "jpm",
      "jxr",
      "key",
      "ktx",
      "lha",
      "lib",
      "lvp",
      "lz",
      "lzh",
      "lzma",
      "lzo",
      "m3u",
      "m4a",
      "m4v",
      "mar",
      "mdi",
      "mht",
      "mid",
      "midi",
      "mj2",
      "mka",
      "mkv",
      "mmr",
      "mng",
      "mobi",
      "mov",
      "movie",
      "mp3",
      "mp4",
      "mp4a",
      "mpeg",
      "mpg",
      "mpga",
      "mxu",
      "nef",
      "npx",
      "numbers",
      "nupkg",
      "o",
      "odp",
      "ods",
      "odt",
      "oga",
      "ogg",
      "ogv",
      "otf",
      "ott",
      "pages",
      "pbm",
      "pcx",
      "pdb",
      "pdf",
      "pea",
      "pgm",
      "pic",
      "png",
      "pnm",
      "pot",
      "potm",
      "potx",
      "ppa",
      "ppam",
      "ppm",
      "pps",
      "ppsm",
      "ppsx",
      "ppt",
      "pptm",
      "pptx",
      "psd",
      "pya",
      "pyc",
      "pyo",
      "pyv",
      "qt",
      "rar",
      "ras",
      "raw",
      "resources",
      "rgb",
      "rip",
      "rlc",
      "rmf",
      "rmvb",
      "rpm",
      "rtf",
      "rz",
      "s3m",
      "s7z",
      "scpt",
      "sgi",
      "shar",
      "snap",
      "sil",
      "sketch",
      "slk",
      "smv",
      "snk",
      "so",
      "stl",
      "suo",
      "sub",
      "swf",
      "tar",
      "tbz",
      "tbz2",
      "tga",
      "tgz",
      "thmx",
      "tif",
      "tiff",
      "tlz",
      "ttc",
      "ttf",
      "txz",
      "udf",
      "uvh",
      "uvi",
      "uvm",
      "uvp",
      "uvs",
      "uvu",
      "viv",
      "vob",
      "war",
      "wav",
      "wax",
      "wbmp",
      "wdp",
      "weba",
      "webm",
      "webp",
      "whl",
      "wim",
      "wm",
      "wma",
      "wmv",
      "wmx",
      "woff",
      "woff2",
      "wrm",
      "wvx",
      "xbm",
      "xif",
      "xla",
      "xlam",
      "xls",
      "xlsb",
      "xlsm",
      "xlsx",
      "xlt",
      "xltm",
      "xltx",
      "xm",
      "xmind",
      "xpi",
      "xpm",
      "xwd",
      "xz",
      "z",
      "zip",
      "zipx"
    ];
  }
});

// node_modules/binary-extensions/index.js
var require_binary_extensions2 = __commonJS({
  "node_modules/binary-extensions/index.js"(exports, module) {
    module.exports = require_binary_extensions();
  }
});

// node_modules/is-binary-path/index.js
var require_is_binary_path = __commonJS({
  "node_modules/is-binary-path/index.js"(exports, module) {
    "use strict";
    var path17 = __require("path");
    var binaryExtensions = require_binary_extensions2();
    var extensions = new Set(binaryExtensions);
    module.exports = (filePath) => extensions.has(path17.extname(filePath).slice(1).toLowerCase());
  }
});

// node_modules/json-sorted-stringify/dist/index.js
var stringify, dist_default23;
var init_dist26 = __esm({
  "node_modules/json-sorted-stringify/dist/index.js"() {
    stringify = (value) => {
      return JSON.stringify(value, (_, value2) => {
        if (typeof value2 === "object" && value2 !== null && !Array.isArray(value2)) {
          const keys = Object.keys(value2).sort();
          const clone = {};
          for (let i = 0, l = keys.length; i < l; i++) {
            const key2 = keys[i];
            clone[key2] = value2[key2];
          }
          return clone;
        }
        return value2;
      });
    };
    dist_default23 = stringify;
  }
});

// node_modules/@prettier/cli/dist/cache.js
import fs8 from "fs";
import path10 from "path";
var Cache, cache_default;
var init_cache = __esm({
  "node_modules/@prettier/cli/dist/cache.js"() {
    init_utils12();
    Cache = class {
      constructor(version, rootPath, options, logger) {
        this.version = sha1hex(version);
        this.logger = logger;
        this.rootPath = rootPath;
        this.storePath = options.cacheLocation || path10.join(getCachePath(rootPath), `${sha1hex(rootPath)}.json`);
        this.store = this.read();
        this.dirty = false;
      }
      cleanup(store) {
        for (const version in store) {
          if (version === this.version)
            continue;
          delete store[version];
          this.dirty = true;
        }
        return store;
      }
      read() {
        try {
          const store = JSON.parse(fs8.readFileSync(this.storePath, "utf8"));
          if (!isObject2(store))
            return {};
          return this.cleanup(store);
        } catch (error) {
          this.logger.prefixed.debug(String(error));
          return {};
        }
      }
      write() {
        if (!this.dirty)
          return;
        try {
          const store = JSON.stringify(this.store);
          fs8.mkdirSync(path10.dirname(this.storePath), { recursive: true });
          fs8.writeFileSync(this.storePath, store);
        } catch (error) {
          this.logger.prefixed.debug(String(error));
        }
      }
      get(filePath) {
        var _a4, _b2;
        const fileRelativePath = fastRelativePath(this.rootPath, filePath);
        const save = this.set.bind(this, filePath, fileRelativePath);
        try {
          const file = (_b2 = (_a4 = this.store[this.version]) == null ? void 0 : _a4.files) == null ? void 0 : _b2[fileRelativePath];
          if (!file || !isArray3(file) || file.length !== 2)
            return { save };
          const [hash, formatted] = file;
          if (!isString3(hash) || !isBoolean2(formatted))
            return { save };
          const content = fs8.readFileSync(filePath);
          const fileHash = sha1base64(content);
          if (hash !== fileHash)
            return { content, save };
          return { formatted, content, save };
        } catch (error) {
          this.logger.prefixed.debug(String(error));
          return { save };
        }
      }
      set(filePath, fileRelativePath, fileFormatted, fileContentExpected) {
        var _a4, _b2;
        try {
          const version = (_a4 = this.store)[_b2 = this.version] || (_a4[_b2] = {});
          const files = version.files || (version.files = {});
          const hash = sha1base64(fileContentExpected);
          version.modified = Date.now();
          files[fileRelativePath] = [hash, fileFormatted];
          this.dirty = true;
        } catch (error) {
          this.logger.prefixed.debug(String(error));
        }
      }
      async has(filePath, isIgnored) {
        var _a5, _b3;
        var _a4, _b2;
        const fileRelativePath = fastRelativePath(this.rootPath, filePath);
        const file = (_b3 = (_a5 = this.store[this.version]) == null ? void 0 : _a5.files) == null ? void 0 : _b3[fileRelativePath];
        if (isUndefined4(file)) {
          const ignored = await isIgnored();
          if (ignored) {
            const version = (_a4 = this.store)[_b2 = this.version] || (_a4[_b2] = {});
            const files = version.files || (version.files = {});
            files[fileRelativePath] = false;
            this.dirty = true;
            return false;
          } else {
            return true;
          }
        } else {
          return !!file;
        }
      }
    };
    cache_default = Cache;
  }
});

// node_modules/ini-simple-parser/dist/utils.js
var inferBoolean, inferNull, inferNumber, inferString, isString4, stripComments;
var init_utils13 = __esm({
  "node_modules/ini-simple-parser/dist/utils.js"() {
    inferBoolean = (value) => {
      if (!isString4(value) || !value.length)
        return value;
      if (value === "true" || value === "TRUE")
        return true;
      if (value === "false" || value === "FALSE")
        return false;
      return value;
    };
    inferNull = (value) => {
      if (!isString4(value) || !value.length)
        return value;
      if (value === "null" || value === "NULL")
        return null;
      return value;
    };
    inferNumber = (value) => {
      if (!isString4(value) || !value.length)
        return value;
      const firstChar = value.charCodeAt(0);
      if (firstChar !== 43 && firstChar !== 45 && firstChar !== 46 && (firstChar < 48 || firstChar > 57))
        return value;
      const number = Number(value);
      if (!Number.isNaN(number))
        value = number;
      return value;
    };
    inferString = (value) => {
      if (!isString4(value) || !value.length)
        return value;
      const firstChar = value[0];
      const lastChar = value[value.length - 1];
      if (firstChar === "'" && lastChar === "'")
        return value.slice(1, -1);
      if (firstChar === '"' && lastChar === '"')
        return value.slice(1, -1);
      return value;
    };
    isString4 = (value) => {
      return typeof value === "string";
    };
    stripComments = (value) => {
      if (!isString4(value) || !value.length)
        return value;
      const comment1Index = value.indexOf("#");
      const comment2Index = value.indexOf(";");
      const commentIndex = comment1Index >= 0 ? comment2Index >= 0 ? Math.min(comment1Index, comment2Index) : comment1Index : comment2Index;
      if (commentIndex < 0)
        return value;
      value = value.slice(0, commentIndex).trimEnd();
      return value;
    };
  }
});

// node_modules/ini-simple-parser/dist/index.js
var parse2, dist_default24;
var init_dist27 = __esm({
  "node_modules/ini-simple-parser/dist/index.js"() {
    init_utils13();
    parse2 = (input, options = {}) => {
      const COMMENT1 = 35;
      const COMMENT2 = 59;
      const SECTION_START = 91;
      const SECTION_END = 93;
      const INFER_BOOLEANS = !!options.inferBooleans;
      const INFER_NULLS = !!options.inferNulls;
      const INFER_NUMBERS = !!options.inferNumbers;
      const INFER_STRINGS = !!options.inferStrings;
      const INLINE_COMMENTS = !!options.inlineComments;
      const results = {};
      const lines = input.split(/\r?\n|\r/g);
      let section = results;
      for (let i = 0, l = lines.length; i < l; i++) {
        const line2 = lines[i].trim();
        if (!line2.length)
          continue;
        const firstChar = line2.charCodeAt(0);
        if (firstChar === COMMENT1 || firstChar === COMMENT2)
          continue;
        const lastChar = line2.charCodeAt(line2.length - 1);
        if (firstChar === SECTION_START) {
          if (lastChar === SECTION_END) {
            const key2 = line2.slice(1, -1);
            section = results[key2] = {};
            continue;
          } else {
            throw new Error(`Unexpected unclosed section at line ${i + 1}`);
          }
        }
        const delimiterIndex = line2.indexOf("=");
        if (delimiterIndex >= 0) {
          let key2 = line2.slice(0, delimiterIndex).trim();
          let value = line2.slice(delimiterIndex + 1).trim();
          if (INLINE_COMMENTS) {
            value = stripComments(value);
          }
          if (INFER_BOOLEANS) {
            value = inferBoolean(value);
          }
          if (INFER_NULLS) {
            value = inferNull(value);
          }
          if (INFER_NUMBERS) {
            value = inferNumber(value);
          }
          if (INFER_STRINGS) {
            key2 = inferString(key2);
            value = inferString(value);
          }
          section[`${key2}`] = value;
          continue;
        }
        throw new Error(`Unexpected characters at line ${i + 1}`);
      }
      return results;
    };
    dist_default24 = parse2;
  }
});

// node_modules/tiny-editorconfig/dist/utils.js
var isBoolean3, isInteger2, isObject3, isObjectEmpty, isString5, isUndefined5;
var init_utils14 = __esm({
  "node_modules/tiny-editorconfig/dist/utils.js"() {
    isBoolean3 = (value) => {
      return typeof value === "boolean";
    };
    isInteger2 = (value) => {
      return Number.isInteger(value);
    };
    isObject3 = (value) => {
      if (value === null)
        return false;
      const type2 = typeof value;
      return type2 === "object" || type2 === "function";
    };
    isObjectEmpty = (value) => {
      for (const _ in value)
        return false;
      return true;
    };
    isString5 = (value) => {
      return typeof value === "string";
    };
    isUndefined5 = (value) => {
      return typeof value === "undefined";
    };
  }
});

// node_modules/tiny-editorconfig/dist/cast.js
var CHARSETS, END_OF_LINES, INDENT_STYLES, isCharset, isEndOfLine, isIndentStyle, cast, cast_default;
var init_cast = __esm({
  "node_modules/tiny-editorconfig/dist/cast.js"() {
    init_utils14();
    CHARSETS = /* @__PURE__ */ new Set(["latin1", "utf-8", "utf-8-bom", "utf-16be", "utf-16le"]);
    END_OF_LINES = /* @__PURE__ */ new Set(["cr", "lf", "crlf"]);
    INDENT_STYLES = /* @__PURE__ */ new Set(["space", "tab"]);
    isCharset = (value) => {
      return CHARSETS.has(value);
    };
    isEndOfLine = (value) => {
      return END_OF_LINES.has(value);
    };
    isIndentStyle = (value) => {
      return INDENT_STYLES.has(value);
    };
    cast = (results, config = {}, includeOverrides = true) => {
      var _a4;
      for (const prop in results) {
        let value = results[prop];
        if (isString5(value)) {
          value = value.toLowerCase();
          if (prop === "charset") {
            if (!isCharset(value))
              continue;
            config.charset = value;
          } else if (prop === "end_of_line") {
            if (!isEndOfLine(value))
              continue;
            config.endOfLine = value;
          } else if (prop === "indent_style") {
            if (!isIndentStyle(value))
              continue;
            config.indentStyle = value;
          }
        } else if (isBoolean3(value)) {
          if (prop === "insert_final_newline") {
            config.insertFinalNewline = value;
          } else if (prop === "root") {
            config.root = value;
          } else if (prop === "trim_trailing_whitespace") {
            config.trimTrailingWhitespace = value;
          }
        } else if (isInteger2(value)) {
          if (value >= 0) {
            if (prop === "indent_size") {
              config.indentSize = value;
            } else if (prop === "tab_width") {
              config.tabWidth = value;
            }
          }
        } else if (isObject3(value)) {
          if (includeOverrides) {
            config.overrides || (config.overrides = {});
            const override = (_a4 = config.overrides)[prop] || (_a4[prop] = {});
            cast(value, override, false);
            if (isObjectEmpty(override)) {
              delete config.overrides[prop];
              if (isObjectEmpty(config.overrides)) {
                delete config.overrides;
              }
            }
          }
        }
      }
      return config;
    };
    cast_default = cast;
  }
});

// node_modules/tiny-editorconfig/dist/parse.js
var parse3, parse_default;
var init_parse = __esm({
  "node_modules/tiny-editorconfig/dist/parse.js"() {
    init_dist27();
    init_cast();
    parse3 = (input) => {
      return cast_default(dist_default24(input, {
        inferBooleans: true,
        inferNumbers: true,
        inferStrings: true,
        inlineComments: true
      }));
    };
    parse_default = parse3;
  }
});

// node_modules/tiny-editorconfig/node_modules/zeptomatch/dist/range.js
var ALPHABET2, int2alpha2, alpha2int2, makeRangeInt2, makeRangePaddedInt2, makeRangeAlpha2;
var init_range2 = __esm({
  "node_modules/tiny-editorconfig/node_modules/zeptomatch/dist/range.js"() {
    ALPHABET2 = "abcdefghijklmnopqrstuvwxyz";
    int2alpha2 = (int2) => {
      let alpha = "";
      while (int2 > 0) {
        const reminder = (int2 - 1) % 26;
        alpha = ALPHABET2[reminder] + alpha;
        int2 = Math.floor((int2 - 1) / 26);
      }
      return alpha;
    };
    alpha2int2 = (str2) => {
      let int2 = 0;
      for (let i = 0, l = str2.length; i < l; i++) {
        int2 = int2 * 26 + ALPHABET2.indexOf(str2[i]) + 1;
      }
      return int2;
    };
    makeRangeInt2 = (start, end) => {
      if (end < start)
        return makeRangeInt2(end, start);
      const range = [];
      while (start <= end) {
        range.push(start++);
      }
      return range;
    };
    makeRangePaddedInt2 = (start, end, paddingLength) => {
      return makeRangeInt2(start, end).map((int2) => String(int2).padStart(paddingLength, "0"));
    };
    makeRangeAlpha2 = (start, end) => {
      return makeRangeInt2(alpha2int2(start), alpha2int2(end)).map(int2alpha2);
    };
  }
});

// node_modules/tiny-editorconfig/node_modules/zeptomatch/dist/utils.js
var identity4, makeParser2, memoize4;
var init_utils15 = __esm({
  "node_modules/tiny-editorconfig/node_modules/zeptomatch/dist/utils.js"() {
    init_dist19();
    identity4 = (value) => {
      return value;
    };
    makeParser2 = (grammar) => {
      return memoize4((input) => {
        return parse(input, grammar, { memoization: false }).join("");
      });
    };
    memoize4 = (fn) => {
      const cache3 = {};
      return (arg) => {
        return cache3[arg] ?? (cache3[arg] = fn(arg));
      };
    };
  }
});

// node_modules/tiny-editorconfig/node_modules/zeptomatch/dist/convert/grammar.js
var FastPathAll, FastPathSimple, FastPathSimples, Escaped3, Escape2, Passthrough3, NegationOdd2, NegationEven2, Negation2, StarStarBetween2, StarStarStart2, StarStarEnd2, StarStarNone2, StarStar2, StarDouble2, StarSingle2, Star2, Question2, ClassOpen2, ClassClose2, ClassNegation2, ClassRange2, ClassEscape2, ClassPassthrough2, ClassValue2, Class2, RangeOpen2, RangeClose2, RangeNumeric2, RangeAlphaLower2, RangeAlphaUpper2, RangeValue2, Range2, BracesOpen2, BracesClose2, BracesComma2, BracesEscape2, BracesPassthrough2, BracesNested2, BracesValue2, Braces2, Grammar3, grammar_default3;
var init_grammar3 = __esm({
  "node_modules/tiny-editorconfig/node_modules/zeptomatch/dist/convert/grammar.js"() {
    init_dist19();
    init_parser3();
    init_range2();
    init_utils15();
    FastPathAll = match(/^\*\*\/\*$/, ".*");
    FastPathSimple = match(/^\*\*\/(\*)?([ a-zA-Z0-9._-]+)$/, (_, $1, $2) => `.*${$1 ? "" : "(?:^|/)"}${$2.replaceAll(".", "\\.")}`);
    FastPathSimples = match(/^\*\*\/(\*)?([ a-zA-Z0-9._-]*)\{([ a-zA-Z0-9._-]+(?:,[ a-zA-Z0-9._-]+)*)\}$/, (_, $1, $2, $3) => `.*${$1 ? "" : "(?:^|/)"}${$2.replaceAll(".", "\\.")}(?:${$3.replaceAll(",", "|").replaceAll(".", "\\.")})`);
    Escaped3 = match(/\\./, identity4);
    Escape2 = match(/[$.*+?^(){}[\]\|]/, (char) => `\\${char}`);
    Passthrough3 = match(/./, identity4);
    NegationOdd2 = match(/^(?:!!)*!(.*)$/, (_, glob) => `(?!^${parser_default3(glob)}$).*?`);
    NegationEven2 = match(/^(!!)+/, "");
    Negation2 = or([NegationOdd2, NegationEven2]);
    StarStarBetween2 = match(/\/(\*\*\/)+/, "(?:/.+/|/)");
    StarStarStart2 = match(/^(\*\*\/)+/, "(?:^|.*/)");
    StarStarEnd2 = match(/\/(\*\*)$/, "(?:/.*|$)");
    StarStarNone2 = match(/\*\*/, ".*");
    StarStar2 = or([StarStarBetween2, StarStarStart2, StarStarEnd2, StarStarNone2]);
    StarDouble2 = match(/\*\/(?!\*\*\/)/, "[^/]*/");
    StarSingle2 = match(/\*/, "[^/]*");
    Star2 = or([StarDouble2, StarSingle2]);
    Question2 = match("?", "[^/]");
    ClassOpen2 = match("[", identity4);
    ClassClose2 = match("]", identity4);
    ClassNegation2 = match(/[!^]/, "^/");
    ClassRange2 = match(/[a-z]-[a-z]|[0-9]-[0-9]/i, identity4);
    ClassEscape2 = match(/[$.*+?^(){}[\|]/, (char) => `\\${char}`);
    ClassPassthrough2 = match(/[^\]]/, identity4);
    ClassValue2 = or([Escaped3, ClassEscape2, ClassRange2, ClassPassthrough2]);
    Class2 = and([ClassOpen2, optional(ClassNegation2), star(ClassValue2), ClassClose2]);
    RangeOpen2 = match("{", "(?:");
    RangeClose2 = match("}", ")");
    RangeNumeric2 = match(/(\d+)\.\.(\d+)/, (_, $1, $2) => makeRangePaddedInt2(+$1, +$2, Math.min($1.length, $2.length)).join("|"));
    RangeAlphaLower2 = match(/([a-z]+)\.\.([a-z]+)/, (_, $1, $2) => makeRangeAlpha2($1, $2).join("|"));
    RangeAlphaUpper2 = match(/([A-Z]+)\.\.([A-Z]+)/, (_, $1, $2) => makeRangeAlpha2($1.toLowerCase(), $2.toLowerCase()).join("|").toUpperCase());
    RangeValue2 = or([RangeNumeric2, RangeAlphaLower2, RangeAlphaUpper2]);
    Range2 = and([RangeOpen2, RangeValue2, RangeClose2]);
    BracesOpen2 = match("{", "(?:");
    BracesClose2 = match("}", ")");
    BracesComma2 = match(",", "|");
    BracesEscape2 = match(/[$.*+?^(){[\]\|]/, (char) => `\\${char}`);
    BracesPassthrough2 = match(/[^}]/, identity4);
    BracesNested2 = lazy(() => Braces2);
    BracesValue2 = or([StarStar2, Star2, Question2, Class2, Range2, BracesNested2, Escaped3, BracesEscape2, BracesComma2, BracesPassthrough2]);
    Braces2 = and([BracesOpen2, star(BracesValue2), BracesClose2]);
    Grammar3 = star(or([FastPathAll, FastPathSimple, FastPathSimples, Negation2, StarStar2, Star2, Question2, Class2, Range2, Braces2, Escaped3, Escape2, Passthrough3]));
    grammar_default3 = Grammar3;
  }
});

// node_modules/tiny-editorconfig/node_modules/zeptomatch/dist/convert/parser.js
var parser3, parser_default3;
var init_parser3 = __esm({
  "node_modules/tiny-editorconfig/node_modules/zeptomatch/dist/convert/parser.js"() {
    init_grammar3();
    init_utils15();
    parser3 = makeParser2(grammar_default3);
    parser_default3 = parser3;
  }
});

// node_modules/tiny-editorconfig/node_modules/zeptomatch/dist/normalize/grammar.js
var Escaped4, Passthrough4, StarStarStar2, StarStarNoLeft2, StarStarNoRight2, Grammar4, grammar_default4;
var init_grammar4 = __esm({
  "node_modules/tiny-editorconfig/node_modules/zeptomatch/dist/normalize/grammar.js"() {
    init_dist19();
    init_utils15();
    Escaped4 = match(/\\./, identity4);
    